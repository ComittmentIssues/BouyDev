
C:\Users\user\Documents\GitHub\BouyDev\Firmware\New folder\Test_Flash_SYS_F4\Debug\Test_Flash_SYS_F4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000021dc  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000018  08002364  08002364  00012364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800237c  0800237c  0001237c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08002380  08002380  00012380  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000003c  20000000  08002384  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  0002003c  2**0
                  CONTENTS
  7 .bss          00000038  2000003c  2000003c  0002003c  2**2
                  ALLOC
  8 ._user_heap_stack 00000400  20000074  20000074  0002003c  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  0002003c  2**0
                  CONTENTS, READONLY
 10 .debug_info   00005b36  00000000  00000000  0002006c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00001330  00000000  00000000  00025ba2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000007f8  00000000  00000000  00026ed8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000720  00000000  00000000  000276d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00002cc1  00000000  00000000  00027df0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000028f0  00000000  00000000  0002aab1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  0002d3a1  2**0
                  CONTENTS, READONLY
 17 .debug_frame  0000200c  00000000  00000000  0002d420  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .stabstr      0000003f  00000000  00000000  0002f42c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	2000003c 	.word	0x2000003c
 80001a4:	00000000 	.word	0x00000000
 80001a8:	0800234c 	.word	0x0800234c

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	20000040 	.word	0x20000040
 80001c4:	0800234c 	.word	0x0800234c

080001c8 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80001c8:	b480      	push	{r7}
 80001ca:	b085      	sub	sp, #20
 80001cc:	af00      	add	r7, sp, #0
 80001ce:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 80001d0:	2300      	movs	r3, #0
 80001d2:	73fb      	strb	r3, [r7, #15]
 80001d4:	2300      	movs	r3, #0
 80001d6:	73bb      	strb	r3, [r7, #14]
 80001d8:	230f      	movs	r3, #15
 80001da:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80001dc:	687b      	ldr	r3, [r7, #4]
 80001de:	78db      	ldrb	r3, [r3, #3]
 80001e0:	2b00      	cmp	r3, #0
 80001e2:	d038      	beq.n	8000256 <NVIC_Init+0x8e>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80001e4:	4b27      	ldr	r3, [pc, #156]	; (8000284 <NVIC_Init+0xbc>)
 80001e6:	68db      	ldr	r3, [r3, #12]
 80001e8:	43db      	mvns	r3, r3
 80001ea:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80001ee:	0a1b      	lsrs	r3, r3, #8
 80001f0:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 80001f2:	7bfb      	ldrb	r3, [r7, #15]
 80001f4:	f1c3 0304 	rsb	r3, r3, #4
 80001f8:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 80001fa:	7b7a      	ldrb	r2, [r7, #13]
 80001fc:	7bfb      	ldrb	r3, [r7, #15]
 80001fe:	fa42 f303 	asr.w	r3, r2, r3
 8000202:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000204:	687b      	ldr	r3, [r7, #4]
 8000206:	785b      	ldrb	r3, [r3, #1]
 8000208:	461a      	mov	r2, r3
 800020a:	7bbb      	ldrb	r3, [r7, #14]
 800020c:	fa02 f303 	lsl.w	r3, r2, r3
 8000210:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8000212:	687b      	ldr	r3, [r7, #4]
 8000214:	789a      	ldrb	r2, [r3, #2]
 8000216:	7b7b      	ldrb	r3, [r7, #13]
 8000218:	4013      	ands	r3, r2
 800021a:	b2da      	uxtb	r2, r3
 800021c:	7bfb      	ldrb	r3, [r7, #15]
 800021e:	4313      	orrs	r3, r2
 8000220:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 8000222:	7bfb      	ldrb	r3, [r7, #15]
 8000224:	011b      	lsls	r3, r3, #4
 8000226:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000228:	4a17      	ldr	r2, [pc, #92]	; (8000288 <NVIC_Init+0xc0>)
 800022a:	687b      	ldr	r3, [r7, #4]
 800022c:	781b      	ldrb	r3, [r3, #0]
 800022e:	4413      	add	r3, r2
 8000230:	7bfa      	ldrb	r2, [r7, #15]
 8000232:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000236:	4a14      	ldr	r2, [pc, #80]	; (8000288 <NVIC_Init+0xc0>)
 8000238:	687b      	ldr	r3, [r7, #4]
 800023a:	781b      	ldrb	r3, [r3, #0]
 800023c:	095b      	lsrs	r3, r3, #5
 800023e:	b2db      	uxtb	r3, r3
 8000240:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000242:	687b      	ldr	r3, [r7, #4]
 8000244:	781b      	ldrb	r3, [r3, #0]
 8000246:	f003 031f 	and.w	r3, r3, #31
 800024a:	2101      	movs	r1, #1
 800024c:	fa01 f303 	lsl.w	r3, r1, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000250:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8000254:	e00f      	b.n	8000276 <NVIC_Init+0xae>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000256:	490c      	ldr	r1, [pc, #48]	; (8000288 <NVIC_Init+0xc0>)
 8000258:	687b      	ldr	r3, [r7, #4]
 800025a:	781b      	ldrb	r3, [r3, #0]
 800025c:	095b      	lsrs	r3, r3, #5
 800025e:	b2db      	uxtb	r3, r3
 8000260:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000262:	687b      	ldr	r3, [r7, #4]
 8000264:	781b      	ldrb	r3, [r3, #0]
 8000266:	f003 031f 	and.w	r3, r3, #31
 800026a:	2201      	movs	r2, #1
 800026c:	409a      	lsls	r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800026e:	f100 0320 	add.w	r3, r0, #32
 8000272:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8000276:	bf00      	nop
 8000278:	3714      	adds	r7, #20
 800027a:	46bd      	mov	sp, r7
 800027c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000280:	4770      	bx	lr
 8000282:	bf00      	nop
 8000284:	e000ed00 	.word	0xe000ed00
 8000288:	e000e100 	.word	0xe000e100

0800028c <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800028c:	b480      	push	{r7}
 800028e:	b085      	sub	sp, #20
 8000290:	af00      	add	r7, sp, #0
 8000292:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8000294:	2300      	movs	r3, #0
 8000296:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 8000298:	4b34      	ldr	r3, [pc, #208]	; (800036c <EXTI_Init+0xe0>)
 800029a:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800029c:	687b      	ldr	r3, [r7, #4]
 800029e:	799b      	ldrb	r3, [r3, #6]
 80002a0:	2b00      	cmp	r3, #0
 80002a2:	d04f      	beq.n	8000344 <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80002a4:	4931      	ldr	r1, [pc, #196]	; (800036c <EXTI_Init+0xe0>)
 80002a6:	4b31      	ldr	r3, [pc, #196]	; (800036c <EXTI_Init+0xe0>)
 80002a8:	681a      	ldr	r2, [r3, #0]
 80002aa:	687b      	ldr	r3, [r7, #4]
 80002ac:	681b      	ldr	r3, [r3, #0]
 80002ae:	43db      	mvns	r3, r3
 80002b0:	4013      	ands	r3, r2
 80002b2:	600b      	str	r3, [r1, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80002b4:	492d      	ldr	r1, [pc, #180]	; (800036c <EXTI_Init+0xe0>)
 80002b6:	4b2d      	ldr	r3, [pc, #180]	; (800036c <EXTI_Init+0xe0>)
 80002b8:	685a      	ldr	r2, [r3, #4]
 80002ba:	687b      	ldr	r3, [r7, #4]
 80002bc:	681b      	ldr	r3, [r3, #0]
 80002be:	43db      	mvns	r3, r3
 80002c0:	4013      	ands	r3, r2
 80002c2:	604b      	str	r3, [r1, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 80002c4:	687b      	ldr	r3, [r7, #4]
 80002c6:	791b      	ldrb	r3, [r3, #4]
 80002c8:	461a      	mov	r2, r3
 80002ca:	68fb      	ldr	r3, [r7, #12]
 80002cc:	4413      	add	r3, r2
 80002ce:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80002d0:	68fb      	ldr	r3, [r7, #12]
 80002d2:	68fa      	ldr	r2, [r7, #12]
 80002d4:	6811      	ldr	r1, [r2, #0]
 80002d6:	687a      	ldr	r2, [r7, #4]
 80002d8:	6812      	ldr	r2, [r2, #0]
 80002da:	430a      	orrs	r2, r1
 80002dc:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80002de:	4923      	ldr	r1, [pc, #140]	; (800036c <EXTI_Init+0xe0>)
 80002e0:	4b22      	ldr	r3, [pc, #136]	; (800036c <EXTI_Init+0xe0>)
 80002e2:	689a      	ldr	r2, [r3, #8]
 80002e4:	687b      	ldr	r3, [r7, #4]
 80002e6:	681b      	ldr	r3, [r3, #0]
 80002e8:	43db      	mvns	r3, r3
 80002ea:	4013      	ands	r3, r2
 80002ec:	608b      	str	r3, [r1, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80002ee:	491f      	ldr	r1, [pc, #124]	; (800036c <EXTI_Init+0xe0>)
 80002f0:	4b1e      	ldr	r3, [pc, #120]	; (800036c <EXTI_Init+0xe0>)
 80002f2:	68da      	ldr	r2, [r3, #12]
 80002f4:	687b      	ldr	r3, [r7, #4]
 80002f6:	681b      	ldr	r3, [r3, #0]
 80002f8:	43db      	mvns	r3, r3
 80002fa:	4013      	ands	r3, r2
 80002fc:	60cb      	str	r3, [r1, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80002fe:	687b      	ldr	r3, [r7, #4]
 8000300:	795b      	ldrb	r3, [r3, #5]
 8000302:	2b10      	cmp	r3, #16
 8000304:	d10e      	bne.n	8000324 <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8000306:	4919      	ldr	r1, [pc, #100]	; (800036c <EXTI_Init+0xe0>)
 8000308:	4b18      	ldr	r3, [pc, #96]	; (800036c <EXTI_Init+0xe0>)
 800030a:	689a      	ldr	r2, [r3, #8]
 800030c:	687b      	ldr	r3, [r7, #4]
 800030e:	681b      	ldr	r3, [r3, #0]
 8000310:	4313      	orrs	r3, r2
 8000312:	608b      	str	r3, [r1, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8000314:	4915      	ldr	r1, [pc, #84]	; (800036c <EXTI_Init+0xe0>)
 8000316:	4b15      	ldr	r3, [pc, #84]	; (800036c <EXTI_Init+0xe0>)
 8000318:	68da      	ldr	r2, [r3, #12]
 800031a:	687b      	ldr	r3, [r7, #4]
 800031c:	681b      	ldr	r3, [r3, #0]
 800031e:	4313      	orrs	r3, r2
 8000320:	60cb      	str	r3, [r1, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8000322:	e01d      	b.n	8000360 <EXTI_Init+0xd4>
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
 8000324:	4b11      	ldr	r3, [pc, #68]	; (800036c <EXTI_Init+0xe0>)
 8000326:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8000328:	687b      	ldr	r3, [r7, #4]
 800032a:	795b      	ldrb	r3, [r3, #5]
 800032c:	461a      	mov	r2, r3
 800032e:	68fb      	ldr	r3, [r7, #12]
 8000330:	4413      	add	r3, r2
 8000332:	60fb      	str	r3, [r7, #12]

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8000334:	68fb      	ldr	r3, [r7, #12]
 8000336:	68fa      	ldr	r2, [r7, #12]
 8000338:	6811      	ldr	r1, [r2, #0]
 800033a:	687a      	ldr	r2, [r7, #4]
 800033c:	6812      	ldr	r2, [r2, #0]
 800033e:	430a      	orrs	r2, r1
 8000340:	601a      	str	r2, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8000342:	e00d      	b.n	8000360 <EXTI_Init+0xd4>
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8000344:	687b      	ldr	r3, [r7, #4]
 8000346:	791b      	ldrb	r3, [r3, #4]
 8000348:	461a      	mov	r2, r3
 800034a:	68fb      	ldr	r3, [r7, #12]
 800034c:	4413      	add	r3, r2
 800034e:	60fb      	str	r3, [r7, #12]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8000350:	68fb      	ldr	r3, [r7, #12]
 8000352:	68fa      	ldr	r2, [r7, #12]
 8000354:	6811      	ldr	r1, [r2, #0]
 8000356:	687a      	ldr	r2, [r7, #4]
 8000358:	6812      	ldr	r2, [r2, #0]
 800035a:	43d2      	mvns	r2, r2
 800035c:	400a      	ands	r2, r1
 800035e:	601a      	str	r2, [r3, #0]
  }
}
 8000360:	bf00      	nop
 8000362:	3714      	adds	r7, #20
 8000364:	46bd      	mov	sp, r7
 8000366:	f85d 7b04 	ldr.w	r7, [sp], #4
 800036a:	4770      	bx	lr
 800036c:	40013c00 	.word	0x40013c00

08000370 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 8000370:	b480      	push	{r7}
 8000372:	b083      	sub	sp, #12
 8000374:	af00      	add	r7, sp, #0
 8000376:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8000378:	4a04      	ldr	r2, [pc, #16]	; (800038c <EXTI_ClearITPendingBit+0x1c>)
 800037a:	687b      	ldr	r3, [r7, #4]
 800037c:	6153      	str	r3, [r2, #20]
}
 800037e:	bf00      	nop
 8000380:	370c      	adds	r7, #12
 8000382:	46bd      	mov	sp, r7
 8000384:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000388:	4770      	bx	lr
 800038a:	bf00      	nop
 800038c:	40013c00 	.word	0x40013c00

08000390 <FLASH_SetLatency>:
  *          For STM32F40xx/41xx and STM32F427x/437x devices this parameter can be   
  *          a value between FLASH_Latency_0 and FLASH_Latency_7.   
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8000390:	b480      	push	{r7}
 8000392:	b083      	sub	sp, #12
 8000394:	af00      	add	r7, sp, #0
 8000396:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8000398:	4b04      	ldr	r3, [pc, #16]	; (80003ac <FLASH_SetLatency+0x1c>)
 800039a:	687a      	ldr	r2, [r7, #4]
 800039c:	b2d2      	uxtb	r2, r2
 800039e:	701a      	strb	r2, [r3, #0]
}
 80003a0:	bf00      	nop
 80003a2:	370c      	adds	r7, #12
 80003a4:	46bd      	mov	sp, r7
 80003a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003aa:	4770      	bx	lr
 80003ac:	40023c00 	.word	0x40023c00

080003b0 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 80003b0:	b480      	push	{r7}
 80003b2:	af00      	add	r7, sp, #0
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 80003b4:	4b07      	ldr	r3, [pc, #28]	; (80003d4 <FLASH_Unlock+0x24>)
 80003b6:	691b      	ldr	r3, [r3, #16]
 80003b8:	2b00      	cmp	r3, #0
 80003ba:	da05      	bge.n	80003c8 <FLASH_Unlock+0x18>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 80003bc:	4b05      	ldr	r3, [pc, #20]	; (80003d4 <FLASH_Unlock+0x24>)
 80003be:	4a06      	ldr	r2, [pc, #24]	; (80003d8 <FLASH_Unlock+0x28>)
 80003c0:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 80003c2:	4b04      	ldr	r3, [pc, #16]	; (80003d4 <FLASH_Unlock+0x24>)
 80003c4:	4a05      	ldr	r2, [pc, #20]	; (80003dc <FLASH_Unlock+0x2c>)
 80003c6:	605a      	str	r2, [r3, #4]
  }  
}
 80003c8:	bf00      	nop
 80003ca:	46bd      	mov	sp, r7
 80003cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003d0:	4770      	bx	lr
 80003d2:	bf00      	nop
 80003d4:	40023c00 	.word	0x40023c00
 80003d8:	45670123 	.word	0x45670123
 80003dc:	cdef89ab 	.word	0xcdef89ab

080003e0 <FLASH_Lock>:
  * @brief  Locks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 80003e0:	b480      	push	{r7}
 80003e2:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 80003e4:	4a05      	ldr	r2, [pc, #20]	; (80003fc <FLASH_Lock+0x1c>)
 80003e6:	4b05      	ldr	r3, [pc, #20]	; (80003fc <FLASH_Lock+0x1c>)
 80003e8:	691b      	ldr	r3, [r3, #16]
 80003ea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80003ee:	6113      	str	r3, [r2, #16]
}
 80003f0:	bf00      	nop
 80003f2:	46bd      	mov	sp, r7
 80003f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003f8:	4770      	bx	lr
 80003fa:	bf00      	nop
 80003fc:	40023c00 	.word	0x40023c00

08000400 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 8000400:	b580      	push	{r7, lr}
 8000402:	b084      	sub	sp, #16
 8000404:	af00      	add	r7, sp, #0
 8000406:	6078      	str	r0, [r7, #4]
 8000408:	460b      	mov	r3, r1
 800040a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0x0;
 800040c:	2300      	movs	r3, #0
 800040e:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 8000410:	2308      	movs	r3, #8
 8000412:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8000414:	78fb      	ldrb	r3, [r7, #3]
 8000416:	2b00      	cmp	r3, #0
 8000418:	d102      	bne.n	8000420 <FLASH_EraseSector+0x20>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 800041a:	2300      	movs	r3, #0
 800041c:	60fb      	str	r3, [r7, #12]
 800041e:	e010      	b.n	8000442 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_2)
 8000420:	78fb      	ldrb	r3, [r7, #3]
 8000422:	2b01      	cmp	r3, #1
 8000424:	d103      	bne.n	800042e <FLASH_EraseSector+0x2e>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8000426:	f44f 7380 	mov.w	r3, #256	; 0x100
 800042a:	60fb      	str	r3, [r7, #12]
 800042c:	e009      	b.n	8000442 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_3)
 800042e:	78fb      	ldrb	r3, [r7, #3]
 8000430:	2b02      	cmp	r3, #2
 8000432:	d103      	bne.n	800043c <FLASH_EraseSector+0x3c>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8000434:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000438:	60fb      	str	r3, [r7, #12]
 800043a:	e002      	b.n	8000442 <FLASH_EraseSector+0x42>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 800043c:	f44f 7340 	mov.w	r3, #768	; 0x300
 8000440:	60fb      	str	r3, [r7, #12]
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000442:	f000 f8a7 	bl	8000594 <FLASH_WaitForLastOperation>
 8000446:	4603      	mov	r3, r0
 8000448:	72fb      	strb	r3, [r7, #11]
  
  if(status == FLASH_COMPLETE)
 800044a:	7afb      	ldrb	r3, [r7, #11]
 800044c:	2b08      	cmp	r3, #8
 800044e:	d12f      	bne.n	80004b0 <FLASH_EraseSector+0xb0>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 8000450:	4a1a      	ldr	r2, [pc, #104]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000452:	4b1a      	ldr	r3, [pc, #104]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000454:	691b      	ldr	r3, [r3, #16]
 8000456:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800045a:	6113      	str	r3, [r2, #16]
    FLASH->CR |= tmp_psize;
 800045c:	4917      	ldr	r1, [pc, #92]	; (80004bc <FLASH_EraseSector+0xbc>)
 800045e:	4b17      	ldr	r3, [pc, #92]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000460:	691a      	ldr	r2, [r3, #16]
 8000462:	68fb      	ldr	r3, [r7, #12]
 8000464:	4313      	orrs	r3, r2
 8000466:	610b      	str	r3, [r1, #16]
    FLASH->CR &= SECTOR_MASK;
 8000468:	4a14      	ldr	r2, [pc, #80]	; (80004bc <FLASH_EraseSector+0xbc>)
 800046a:	4b14      	ldr	r3, [pc, #80]	; (80004bc <FLASH_EraseSector+0xbc>)
 800046c:	691b      	ldr	r3, [r3, #16]
 800046e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000472:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 8000474:	4911      	ldr	r1, [pc, #68]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000476:	4b11      	ldr	r3, [pc, #68]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000478:	691a      	ldr	r2, [r3, #16]
 800047a:	687b      	ldr	r3, [r7, #4]
 800047c:	4313      	orrs	r3, r2
 800047e:	f043 0302 	orr.w	r3, r3, #2
 8000482:	610b      	str	r3, [r1, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8000484:	4a0d      	ldr	r2, [pc, #52]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000486:	4b0d      	ldr	r3, [pc, #52]	; (80004bc <FLASH_EraseSector+0xbc>)
 8000488:	691b      	ldr	r3, [r3, #16]
 800048a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800048e:	6113      	str	r3, [r2, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000490:	f000 f880 	bl	8000594 <FLASH_WaitForLastOperation>
 8000494:	4603      	mov	r3, r0
 8000496:	72fb      	strb	r3, [r7, #11]
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 8000498:	4a08      	ldr	r2, [pc, #32]	; (80004bc <FLASH_EraseSector+0xbc>)
 800049a:	4b08      	ldr	r3, [pc, #32]	; (80004bc <FLASH_EraseSector+0xbc>)
 800049c:	691b      	ldr	r3, [r3, #16]
 800049e:	f023 0302 	bic.w	r3, r3, #2
 80004a2:	6113      	str	r3, [r2, #16]
    FLASH->CR &= SECTOR_MASK; 
 80004a4:	4a05      	ldr	r2, [pc, #20]	; (80004bc <FLASH_EraseSector+0xbc>)
 80004a6:	4b05      	ldr	r3, [pc, #20]	; (80004bc <FLASH_EraseSector+0xbc>)
 80004a8:	691b      	ldr	r3, [r3, #16]
 80004aa:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80004ae:	6113      	str	r3, [r2, #16]
  }
  /* Return the Erase Status */
  return status;
 80004b0:	7afb      	ldrb	r3, [r7, #11]
}
 80004b2:	4618      	mov	r0, r3
 80004b4:	3710      	adds	r7, #16
 80004b6:	46bd      	mov	sp, r7
 80004b8:	bd80      	pop	{r7, pc}
 80004ba:	bf00      	nop
 80004bc:	40023c00 	.word	0x40023c00

080004c0 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 80004c0:	b580      	push	{r7, lr}
 80004c2:	b084      	sub	sp, #16
 80004c4:	af00      	add	r7, sp, #0
 80004c6:	6078      	str	r0, [r7, #4]
 80004c8:	460b      	mov	r3, r1
 80004ca:	807b      	strh	r3, [r7, #2]
  FLASH_Status status = FLASH_COMPLETE;
 80004cc:	2308      	movs	r3, #8
 80004ce:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80004d0:	f000 f860 	bl	8000594 <FLASH_WaitForLastOperation>
 80004d4:	4603      	mov	r3, r0
 80004d6:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 80004d8:	7bfb      	ldrb	r3, [r7, #15]
 80004da:	2b08      	cmp	r3, #8
 80004dc:	d11e      	bne.n	800051c <FLASH_ProgramHalfWord+0x5c>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 80004de:	4a12      	ldr	r2, [pc, #72]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004e0:	4b11      	ldr	r3, [pc, #68]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004e2:	691b      	ldr	r3, [r3, #16]
 80004e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80004e8:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 80004ea:	4a0f      	ldr	r2, [pc, #60]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004ec:	4b0e      	ldr	r3, [pc, #56]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004ee:	691b      	ldr	r3, [r3, #16]
 80004f0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80004f4:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 80004f6:	4a0c      	ldr	r2, [pc, #48]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004f8:	4b0b      	ldr	r3, [pc, #44]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 80004fa:	691b      	ldr	r3, [r3, #16]
 80004fc:	f043 0301 	orr.w	r3, r3, #1
 8000500:	6113      	str	r3, [r2, #16]
  
    *(__IO uint16_t*)Address = Data;
 8000502:	687b      	ldr	r3, [r7, #4]
 8000504:	887a      	ldrh	r2, [r7, #2]
 8000506:	801a      	strh	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000508:	f000 f844 	bl	8000594 <FLASH_WaitForLastOperation>
 800050c:	4603      	mov	r3, r0
 800050e:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000510:	4a05      	ldr	r2, [pc, #20]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 8000512:	4b05      	ldr	r3, [pc, #20]	; (8000528 <FLASH_ProgramHalfWord+0x68>)
 8000514:	691b      	ldr	r3, [r3, #16]
 8000516:	f023 0301 	bic.w	r3, r3, #1
 800051a:	6113      	str	r3, [r2, #16]
  } 
  /* Return the Program Status */
  return status;
 800051c:	7bfb      	ldrb	r3, [r7, #15]
}
 800051e:	4618      	mov	r0, r3
 8000520:	3710      	adds	r7, #16
 8000522:	46bd      	mov	sp, r7
 8000524:	bd80      	pop	{r7, pc}
 8000526:	bf00      	nop
 8000528:	40023c00 	.word	0x40023c00

0800052c <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_GetStatus(void)
{
 800052c:	b480      	push	{r7}
 800052e:	b083      	sub	sp, #12
 8000530:	af00      	add	r7, sp, #0
  FLASH_Status flashstatus = FLASH_COMPLETE;
 8000532:	2308      	movs	r3, #8
 8000534:	71fb      	strb	r3, [r7, #7]
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8000536:	4b16      	ldr	r3, [pc, #88]	; (8000590 <FLASH_GetStatus+0x64>)
 8000538:	68db      	ldr	r3, [r3, #12]
 800053a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800053e:	2b00      	cmp	r3, #0
 8000540:	d002      	beq.n	8000548 <FLASH_GetStatus+0x1c>
  {
    flashstatus = FLASH_BUSY;
 8000542:	2301      	movs	r3, #1
 8000544:	71fb      	strb	r3, [r7, #7]
 8000546:	e01c      	b.n	8000582 <FLASH_GetStatus+0x56>
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 8000548:	4b11      	ldr	r3, [pc, #68]	; (8000590 <FLASH_GetStatus+0x64>)
 800054a:	68db      	ldr	r3, [r3, #12]
 800054c:	f003 0310 	and.w	r3, r3, #16
 8000550:	2b00      	cmp	r3, #0
 8000552:	d002      	beq.n	800055a <FLASH_GetStatus+0x2e>
    { 
      flashstatus = FLASH_ERROR_WRP;
 8000554:	2305      	movs	r3, #5
 8000556:	71fb      	strb	r3, [r7, #7]
 8000558:	e013      	b.n	8000582 <FLASH_GetStatus+0x56>
    }
    else
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 800055a:	4b0d      	ldr	r3, [pc, #52]	; (8000590 <FLASH_GetStatus+0x64>)
 800055c:	68db      	ldr	r3, [r3, #12]
 800055e:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 8000562:	2b00      	cmp	r3, #0
 8000564:	d002      	beq.n	800056c <FLASH_GetStatus+0x40>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
 8000566:	2306      	movs	r3, #6
 8000568:	71fb      	strb	r3, [r7, #7]
 800056a:	e00a      	b.n	8000582 <FLASH_GetStatus+0x56>
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 800056c:	4b08      	ldr	r3, [pc, #32]	; (8000590 <FLASH_GetStatus+0x64>)
 800056e:	68db      	ldr	r3, [r3, #12]
 8000570:	f003 0302 	and.w	r3, r3, #2
 8000574:	2b00      	cmp	r3, #0
 8000576:	d002      	beq.n	800057e <FLASH_GetStatus+0x52>
        {
          flashstatus = FLASH_ERROR_OPERATION;
 8000578:	2307      	movs	r3, #7
 800057a:	71fb      	strb	r3, [r7, #7]
 800057c:	e001      	b.n	8000582 <FLASH_GetStatus+0x56>
        }
        else
        {
          flashstatus = FLASH_COMPLETE;
 800057e:	2308      	movs	r3, #8
 8000580:	71fb      	strb	r3, [r7, #7]
        }
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
 8000582:	79fb      	ldrb	r3, [r7, #7]
}
 8000584:	4618      	mov	r0, r3
 8000586:	370c      	adds	r7, #12
 8000588:	46bd      	mov	sp, r7
 800058a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800058e:	4770      	bx	lr
 8000590:	40023c00 	.word	0x40023c00

08000594 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8000594:	b580      	push	{r7, lr}
 8000596:	b082      	sub	sp, #8
 8000598:	af00      	add	r7, sp, #0
  __IO FLASH_Status status = FLASH_COMPLETE;
 800059a:	2308      	movs	r3, #8
 800059c:	71fb      	strb	r3, [r7, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 800059e:	f7ff ffc5 	bl	800052c <FLASH_GetStatus>
 80005a2:	4603      	mov	r3, r0
 80005a4:	71fb      	strb	r3, [r7, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 80005a6:	e003      	b.n	80005b0 <FLASH_WaitForLastOperation+0x1c>
  {
    status = FLASH_GetStatus();
 80005a8:	f7ff ffc0 	bl	800052c <FLASH_GetStatus>
 80005ac:	4603      	mov	r3, r0
 80005ae:	71fb      	strb	r3, [r7, #7]
  status = FLASH_GetStatus();

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 80005b0:	79fb      	ldrb	r3, [r7, #7]
 80005b2:	b2db      	uxtb	r3, r3
 80005b4:	2b01      	cmp	r3, #1
 80005b6:	d0f7      	beq.n	80005a8 <FLASH_WaitForLastOperation+0x14>
  {
    status = FLASH_GetStatus();
  }
  /* Return the operation status */
  return status;
 80005b8:	79fb      	ldrb	r3, [r7, #7]
 80005ba:	b2db      	uxtb	r3, r3
}
 80005bc:	4618      	mov	r0, r3
 80005be:	3708      	adds	r7, #8
 80005c0:	46bd      	mov	sp, r7
 80005c2:	bd80      	pop	{r7, pc}

080005c4 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80005c4:	b480      	push	{r7}
 80005c6:	b087      	sub	sp, #28
 80005c8:	af00      	add	r7, sp, #0
 80005ca:	6078      	str	r0, [r7, #4]
 80005cc:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 80005ce:	2300      	movs	r3, #0
 80005d0:	617b      	str	r3, [r7, #20]
 80005d2:	2300      	movs	r3, #0
 80005d4:	613b      	str	r3, [r7, #16]
 80005d6:	2300      	movs	r3, #0
 80005d8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80005da:	2300      	movs	r3, #0
 80005dc:	617b      	str	r3, [r7, #20]
 80005de:	e076      	b.n	80006ce <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80005e0:	2201      	movs	r2, #1
 80005e2:	697b      	ldr	r3, [r7, #20]
 80005e4:	fa02 f303 	lsl.w	r3, r2, r3
 80005e8:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80005ea:	683b      	ldr	r3, [r7, #0]
 80005ec:	681a      	ldr	r2, [r3, #0]
 80005ee:	693b      	ldr	r3, [r7, #16]
 80005f0:	4013      	ands	r3, r2
 80005f2:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 80005f4:	68fa      	ldr	r2, [r7, #12]
 80005f6:	693b      	ldr	r3, [r7, #16]
 80005f8:	429a      	cmp	r2, r3
 80005fa:	d165      	bne.n	80006c8 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80005fc:	687b      	ldr	r3, [r7, #4]
 80005fe:	681a      	ldr	r2, [r3, #0]
 8000600:	697b      	ldr	r3, [r7, #20]
 8000602:	005b      	lsls	r3, r3, #1
 8000604:	2103      	movs	r1, #3
 8000606:	fa01 f303 	lsl.w	r3, r1, r3
 800060a:	43db      	mvns	r3, r3
 800060c:	401a      	ands	r2, r3
 800060e:	687b      	ldr	r3, [r7, #4]
 8000610:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8000612:	687b      	ldr	r3, [r7, #4]
 8000614:	681a      	ldr	r2, [r3, #0]
 8000616:	683b      	ldr	r3, [r7, #0]
 8000618:	791b      	ldrb	r3, [r3, #4]
 800061a:	4619      	mov	r1, r3
 800061c:	697b      	ldr	r3, [r7, #20]
 800061e:	005b      	lsls	r3, r3, #1
 8000620:	fa01 f303 	lsl.w	r3, r1, r3
 8000624:	431a      	orrs	r2, r3
 8000626:	687b      	ldr	r3, [r7, #4]
 8000628:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800062a:	683b      	ldr	r3, [r7, #0]
 800062c:	791b      	ldrb	r3, [r3, #4]
 800062e:	2b01      	cmp	r3, #1
 8000630:	d003      	beq.n	800063a <GPIO_Init+0x76>
 8000632:	683b      	ldr	r3, [r7, #0]
 8000634:	791b      	ldrb	r3, [r3, #4]
 8000636:	2b02      	cmp	r3, #2
 8000638:	d12e      	bne.n	8000698 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800063a:	687b      	ldr	r3, [r7, #4]
 800063c:	689a      	ldr	r2, [r3, #8]
 800063e:	697b      	ldr	r3, [r7, #20]
 8000640:	005b      	lsls	r3, r3, #1
 8000642:	2103      	movs	r1, #3
 8000644:	fa01 f303 	lsl.w	r3, r1, r3
 8000648:	43db      	mvns	r3, r3
 800064a:	401a      	ands	r2, r3
 800064c:	687b      	ldr	r3, [r7, #4]
 800064e:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8000650:	687b      	ldr	r3, [r7, #4]
 8000652:	689a      	ldr	r2, [r3, #8]
 8000654:	683b      	ldr	r3, [r7, #0]
 8000656:	795b      	ldrb	r3, [r3, #5]
 8000658:	4619      	mov	r1, r3
 800065a:	697b      	ldr	r3, [r7, #20]
 800065c:	005b      	lsls	r3, r3, #1
 800065e:	fa01 f303 	lsl.w	r3, r1, r3
 8000662:	431a      	orrs	r2, r3
 8000664:	687b      	ldr	r3, [r7, #4]
 8000666:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8000668:	687b      	ldr	r3, [r7, #4]
 800066a:	685a      	ldr	r2, [r3, #4]
 800066c:	697b      	ldr	r3, [r7, #20]
 800066e:	b29b      	uxth	r3, r3
 8000670:	2101      	movs	r1, #1
 8000672:	fa01 f303 	lsl.w	r3, r1, r3
 8000676:	43db      	mvns	r3, r3
 8000678:	401a      	ands	r2, r3
 800067a:	687b      	ldr	r3, [r7, #4]
 800067c:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800067e:	687b      	ldr	r3, [r7, #4]
 8000680:	685a      	ldr	r2, [r3, #4]
 8000682:	683b      	ldr	r3, [r7, #0]
 8000684:	799b      	ldrb	r3, [r3, #6]
 8000686:	4619      	mov	r1, r3
 8000688:	697b      	ldr	r3, [r7, #20]
 800068a:	b29b      	uxth	r3, r3
 800068c:	fa01 f303 	lsl.w	r3, r1, r3
 8000690:	b29b      	uxth	r3, r3
 8000692:	431a      	orrs	r2, r3
 8000694:	687b      	ldr	r3, [r7, #4]
 8000696:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8000698:	687b      	ldr	r3, [r7, #4]
 800069a:	68da      	ldr	r2, [r3, #12]
 800069c:	697b      	ldr	r3, [r7, #20]
 800069e:	b29b      	uxth	r3, r3
 80006a0:	005b      	lsls	r3, r3, #1
 80006a2:	2103      	movs	r1, #3
 80006a4:	fa01 f303 	lsl.w	r3, r1, r3
 80006a8:	43db      	mvns	r3, r3
 80006aa:	401a      	ands	r2, r3
 80006ac:	687b      	ldr	r3, [r7, #4]
 80006ae:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80006b0:	687b      	ldr	r3, [r7, #4]
 80006b2:	68da      	ldr	r2, [r3, #12]
 80006b4:	683b      	ldr	r3, [r7, #0]
 80006b6:	79db      	ldrb	r3, [r3, #7]
 80006b8:	4619      	mov	r1, r3
 80006ba:	697b      	ldr	r3, [r7, #20]
 80006bc:	005b      	lsls	r3, r3, #1
 80006be:	fa01 f303 	lsl.w	r3, r1, r3
 80006c2:	431a      	orrs	r2, r3
 80006c4:	687b      	ldr	r3, [r7, #4]
 80006c6:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80006c8:	697b      	ldr	r3, [r7, #20]
 80006ca:	3301      	adds	r3, #1
 80006cc:	617b      	str	r3, [r7, #20]
 80006ce:	697b      	ldr	r3, [r7, #20]
 80006d0:	2b0f      	cmp	r3, #15
 80006d2:	d985      	bls.n	80005e0 <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80006d4:	bf00      	nop
 80006d6:	371c      	adds	r7, #28
 80006d8:	46bd      	mov	sp, r7
 80006da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80006de:	4770      	bx	lr

080006e0 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the backup domain.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 80006e0:	b480      	push	{r7}
 80006e2:	b083      	sub	sp, #12
 80006e4:	af00      	add	r7, sp, #0
 80006e6:	4603      	mov	r3, r0
 80006e8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80006ea:	4a04      	ldr	r2, [pc, #16]	; (80006fc <PWR_BackupAccessCmd+0x1c>)
 80006ec:	79fb      	ldrb	r3, [r7, #7]
 80006ee:	6013      	str	r3, [r2, #0]
}
 80006f0:	bf00      	nop
 80006f2:	370c      	adds	r7, #12
 80006f4:	46bd      	mov	sp, r7
 80006f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80006fa:	4770      	bx	lr
 80006fc:	420e0020 	.word	0x420e0020

08000700 <PWR_GetFlagStatus>:
  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
  *                 scaling output selection is ready. 
  * @retval The new state of PWR_FLAG (SET or RESET).
  */
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
{
 8000700:	b480      	push	{r7}
 8000702:	b085      	sub	sp, #20
 8000704:	af00      	add	r7, sp, #0
 8000706:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8000708:	2300      	movs	r3, #0
 800070a:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 800070c:	4b08      	ldr	r3, [pc, #32]	; (8000730 <PWR_GetFlagStatus+0x30>)
 800070e:	685a      	ldr	r2, [r3, #4]
 8000710:	687b      	ldr	r3, [r7, #4]
 8000712:	4013      	ands	r3, r2
 8000714:	2b00      	cmp	r3, #0
 8000716:	d002      	beq.n	800071e <PWR_GetFlagStatus+0x1e>
  {
    bitstatus = SET;
 8000718:	2301      	movs	r3, #1
 800071a:	73fb      	strb	r3, [r7, #15]
 800071c:	e001      	b.n	8000722 <PWR_GetFlagStatus+0x22>
  }
  else
  {
    bitstatus = RESET;
 800071e:	2300      	movs	r3, #0
 8000720:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 8000722:	7bfb      	ldrb	r3, [r7, #15]
}
 8000724:	4618      	mov	r0, r3
 8000726:	3714      	adds	r7, #20
 8000728:	46bd      	mov	sp, r7
 800072a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800072e:	4770      	bx	lr
 8000730:	40007000 	.word	0x40007000

08000734 <PWR_ClearFlag>:
  *            @arg PWR_FLAG_WU: Wake Up flag
  *            @arg PWR_FLAG_SB: StandBy flag
  * @retval None
  */
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
 8000734:	b480      	push	{r7}
 8000736:	b083      	sub	sp, #12
 8000738:	af00      	add	r7, sp, #0
 800073a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 800073c:	4906      	ldr	r1, [pc, #24]	; (8000758 <PWR_ClearFlag+0x24>)
 800073e:	4b06      	ldr	r3, [pc, #24]	; (8000758 <PWR_ClearFlag+0x24>)
 8000740:	681a      	ldr	r2, [r3, #0]
 8000742:	687b      	ldr	r3, [r7, #4]
 8000744:	009b      	lsls	r3, r3, #2
 8000746:	4313      	orrs	r3, r2
 8000748:	600b      	str	r3, [r1, #0]
}
 800074a:	bf00      	nop
 800074c:	370c      	adds	r7, #12
 800074e:	46bd      	mov	sp, r7
 8000750:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000754:	4770      	bx	lr
 8000756:	bf00      	nop
 8000758:	40007000 	.word	0x40007000

0800075c <RCC_DeInit>:
  *            - LSI, LSE and RTC clocks 
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 800075c:	b480      	push	{r7}
 800075e:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000760:	4a12      	ldr	r2, [pc, #72]	; (80007ac <RCC_DeInit+0x50>)
 8000762:	4b12      	ldr	r3, [pc, #72]	; (80007ac <RCC_DeInit+0x50>)
 8000764:	681b      	ldr	r3, [r3, #0]
 8000766:	f043 0301 	orr.w	r3, r3, #1
 800076a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800076c:	4b0f      	ldr	r3, [pc, #60]	; (80007ac <RCC_DeInit+0x50>)
 800076e:	2200      	movs	r2, #0
 8000770:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON, PLLON and PLLI2S bits */
  RCC->CR &= (uint32_t)0xFAF6FFFF;
 8000772:	4a0e      	ldr	r2, [pc, #56]	; (80007ac <RCC_DeInit+0x50>)
 8000774:	4b0d      	ldr	r3, [pc, #52]	; (80007ac <RCC_DeInit+0x50>)
 8000776:	681b      	ldr	r3, [r3, #0]
 8000778:	f023 63a1 	bic.w	r3, r3, #84410368	; 0x5080000
 800077c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000780:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000782:	4b0a      	ldr	r3, [pc, #40]	; (80007ac <RCC_DeInit+0x50>)
 8000784:	4a0a      	ldr	r2, [pc, #40]	; (80007b0 <RCC_DeInit+0x54>)
 8000786:	605a      	str	r2, [r3, #4]

  /* Reset PLLI2SCFGR register */
  RCC->PLLI2SCFGR = 0x20003000;
 8000788:	4b08      	ldr	r3, [pc, #32]	; (80007ac <RCC_DeInit+0x50>)
 800078a:	4a0a      	ldr	r2, [pc, #40]	; (80007b4 <RCC_DeInit+0x58>)
 800078c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000790:	4a06      	ldr	r2, [pc, #24]	; (80007ac <RCC_DeInit+0x50>)
 8000792:	4b06      	ldr	r3, [pc, #24]	; (80007ac <RCC_DeInit+0x50>)
 8000794:	681b      	ldr	r3, [r3, #0]
 8000796:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800079a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800079c:	4b03      	ldr	r3, [pc, #12]	; (80007ac <RCC_DeInit+0x50>)
 800079e:	2200      	movs	r2, #0
 80007a0:	60da      	str	r2, [r3, #12]
#ifdef STM32F427X 
  /* Disable Timers clock prescalers selection */
  RCC->DCKCFGR = 0x00000000;
#endif /* STM32F427X */ 

}
 80007a2:	bf00      	nop
 80007a4:	46bd      	mov	sp, r7
 80007a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007aa:	4770      	bx	lr
 80007ac:	40023800 	.word	0x40023800
 80007b0:	24003010 	.word	0x24003010
 80007b4:	20003000 	.word	0x20003000

080007b8 <RCC_HSEConfig>:
  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint8_t RCC_HSE)
{
 80007b8:	b480      	push	{r7}
 80007ba:	b083      	sub	sp, #12
 80007bc:	af00      	add	r7, sp, #0
 80007be:	4603      	mov	r3, r0
 80007c0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 80007c2:	4b06      	ldr	r3, [pc, #24]	; (80007dc <RCC_HSEConfig+0x24>)
 80007c4:	2200      	movs	r2, #0
 80007c6:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 80007c8:	4a04      	ldr	r2, [pc, #16]	; (80007dc <RCC_HSEConfig+0x24>)
 80007ca:	79fb      	ldrb	r3, [r7, #7]
 80007cc:	7013      	strb	r3, [r2, #0]
}
 80007ce:	bf00      	nop
 80007d0:	370c      	adds	r7, #12
 80007d2:	46bd      	mov	sp, r7
 80007d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007d8:	4770      	bx	lr
 80007da:	bf00      	nop
 80007dc:	40023802 	.word	0x40023802

080007e0 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80007e0:	b580      	push	{r7, lr}
 80007e2:	b082      	sub	sp, #8
 80007e4:	af00      	add	r7, sp, #0
  __IO uint32_t startupcounter = 0;
 80007e6:	2300      	movs	r3, #0
 80007e8:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 80007ea:	2300      	movs	r3, #0
 80007ec:	71fb      	strb	r3, [r7, #7]
  FlagStatus hsestatus = RESET;
 80007ee:	2300      	movs	r3, #0
 80007f0:	71bb      	strb	r3, [r7, #6]
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80007f2:	2031      	movs	r0, #49	; 0x31
 80007f4:	f000 fa36 	bl	8000c64 <RCC_GetFlagStatus>
 80007f8:	4603      	mov	r3, r0
 80007fa:	71bb      	strb	r3, [r7, #6]
    startupcounter++;
 80007fc:	683b      	ldr	r3, [r7, #0]
 80007fe:	3301      	adds	r3, #1
 8000800:	603b      	str	r3, [r7, #0]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8000802:	683b      	ldr	r3, [r7, #0]
 8000804:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000808:	d002      	beq.n	8000810 <RCC_WaitForHSEStartUp+0x30>
 800080a:	79bb      	ldrb	r3, [r7, #6]
 800080c:	2b00      	cmp	r3, #0
 800080e:	d0f0      	beq.n	80007f2 <RCC_WaitForHSEStartUp+0x12>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8000810:	2031      	movs	r0, #49	; 0x31
 8000812:	f000 fa27 	bl	8000c64 <RCC_GetFlagStatus>
 8000816:	4603      	mov	r3, r0
 8000818:	2b00      	cmp	r3, #0
 800081a:	d002      	beq.n	8000822 <RCC_WaitForHSEStartUp+0x42>
  {
    status = SUCCESS;
 800081c:	2301      	movs	r3, #1
 800081e:	71fb      	strb	r3, [r7, #7]
 8000820:	e001      	b.n	8000826 <RCC_WaitForHSEStartUp+0x46>
  }
  else
  {
    status = ERROR;
 8000822:	2300      	movs	r3, #0
 8000824:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 8000826:	79fb      	ldrb	r3, [r7, #7]
}
 8000828:	4618      	mov	r0, r3
 800082a:	3708      	adds	r7, #8
 800082c:	46bd      	mov	sp, r7
 800082e:	bd80      	pop	{r7, pc}

08000830 <RCC_LSICmd>:
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles. 
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
 8000830:	b480      	push	{r7}
 8000832:	b083      	sub	sp, #12
 8000834:	af00      	add	r7, sp, #0
 8000836:	4603      	mov	r3, r0
 8000838:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 800083a:	4a04      	ldr	r2, [pc, #16]	; (800084c <RCC_LSICmd+0x1c>)
 800083c:	79fb      	ldrb	r3, [r7, #7]
 800083e:	6013      	str	r3, [r2, #0]
}
 8000840:	bf00      	nop
 8000842:	370c      	adds	r7, #12
 8000844:	46bd      	mov	sp, r7
 8000846:	f85d 7b04 	ldr.w	r7, [sp], #4
 800084a:	4770      	bx	lr
 800084c:	42470e80 	.word	0x42470e80

08000850 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8000850:	b480      	push	{r7}
 8000852:	b085      	sub	sp, #20
 8000854:	af00      	add	r7, sp, #0
 8000856:	60f8      	str	r0, [r7, #12]
 8000858:	60b9      	str	r1, [r7, #8]
 800085a:	607a      	str	r2, [r7, #4]
 800085c:	603b      	str	r3, [r7, #0]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 800085e:	490b      	ldr	r1, [pc, #44]	; (800088c <RCC_PLLConfig+0x3c>)
 8000860:	687b      	ldr	r3, [r7, #4]
 8000862:	019a      	lsls	r2, r3, #6
 8000864:	68bb      	ldr	r3, [r7, #8]
 8000866:	431a      	orrs	r2, r3
 8000868:	683b      	ldr	r3, [r7, #0]
 800086a:	085b      	lsrs	r3, r3, #1
 800086c:	3b01      	subs	r3, #1
 800086e:	041b      	lsls	r3, r3, #16
 8000870:	431a      	orrs	r2, r3
 8000872:	68fb      	ldr	r3, [r7, #12]
 8000874:	431a      	orrs	r2, r3
                 (PLLQ << 24);
 8000876:	69bb      	ldr	r3, [r7, #24]
 8000878:	061b      	lsls	r3, r3, #24
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 800087a:	4313      	orrs	r3, r2
 800087c:	604b      	str	r3, [r1, #4]
                 (PLLQ << 24);
}
 800087e:	bf00      	nop
 8000880:	3714      	adds	r7, #20
 8000882:	46bd      	mov	sp, r7
 8000884:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000888:	4770      	bx	lr
 800088a:	bf00      	nop
 800088c:	40023800 	.word	0x40023800

08000890 <RCC_PLLCmd>:
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 8000890:	b480      	push	{r7}
 8000892:	b083      	sub	sp, #12
 8000894:	af00      	add	r7, sp, #0
 8000896:	4603      	mov	r3, r0
 8000898:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800089a:	4a04      	ldr	r2, [pc, #16]	; (80008ac <RCC_PLLCmd+0x1c>)
 800089c:	79fb      	ldrb	r3, [r7, #7]
 800089e:	6013      	str	r3, [r2, #0]
}
 80008a0:	bf00      	nop
 80008a2:	370c      	adds	r7, #12
 80008a4:	46bd      	mov	sp, r7
 80008a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008aa:	4770      	bx	lr
 80008ac:	42470060 	.word	0x42470060

080008b0 <RCC_SYSCLKConfig>:
  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 80008b0:	b480      	push	{r7}
 80008b2:	b085      	sub	sp, #20
 80008b4:	af00      	add	r7, sp, #0
 80008b6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80008b8:	2300      	movs	r3, #0
 80008ba:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80008bc:	4b09      	ldr	r3, [pc, #36]	; (80008e4 <RCC_SYSCLKConfig+0x34>)
 80008be:	689b      	ldr	r3, [r3, #8]
 80008c0:	60fb      	str	r3, [r7, #12]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80008c2:	68fb      	ldr	r3, [r7, #12]
 80008c4:	f023 0303 	bic.w	r3, r3, #3
 80008c8:	60fb      	str	r3, [r7, #12]

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80008ca:	68fa      	ldr	r2, [r7, #12]
 80008cc:	687b      	ldr	r3, [r7, #4]
 80008ce:	4313      	orrs	r3, r2
 80008d0:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80008d2:	4a04      	ldr	r2, [pc, #16]	; (80008e4 <RCC_SYSCLKConfig+0x34>)
 80008d4:	68fb      	ldr	r3, [r7, #12]
 80008d6:	6093      	str	r3, [r2, #8]
}
 80008d8:	bf00      	nop
 80008da:	3714      	adds	r7, #20
 80008dc:	46bd      	mov	sp, r7
 80008de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008e2:	4770      	bx	lr
 80008e4:	40023800 	.word	0x40023800

080008e8 <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 80008e8:	b480      	push	{r7}
 80008ea:	b085      	sub	sp, #20
 80008ec:	af00      	add	r7, sp, #0
 80008ee:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80008f0:	2300      	movs	r3, #0
 80008f2:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80008f4:	4b09      	ldr	r3, [pc, #36]	; (800091c <RCC_HCLKConfig+0x34>)
 80008f6:	689b      	ldr	r3, [r3, #8]
 80008f8:	60fb      	str	r3, [r7, #12]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 80008fa:	68fb      	ldr	r3, [r7, #12]
 80008fc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000900:	60fb      	str	r3, [r7, #12]

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8000902:	68fa      	ldr	r2, [r7, #12]
 8000904:	687b      	ldr	r3, [r7, #4]
 8000906:	4313      	orrs	r3, r2
 8000908:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800090a:	4a04      	ldr	r2, [pc, #16]	; (800091c <RCC_HCLKConfig+0x34>)
 800090c:	68fb      	ldr	r3, [r7, #12]
 800090e:	6093      	str	r3, [r2, #8]
}
 8000910:	bf00      	nop
 8000912:	3714      	adds	r7, #20
 8000914:	46bd      	mov	sp, r7
 8000916:	f85d 7b04 	ldr.w	r7, [sp], #4
 800091a:	4770      	bx	lr
 800091c:	40023800 	.word	0x40023800

08000920 <RCC_PCLK1Config>:
  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 8000920:	b480      	push	{r7}
 8000922:	b085      	sub	sp, #20
 8000924:	af00      	add	r7, sp, #0
 8000926:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8000928:	2300      	movs	r3, #0
 800092a:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800092c:	4b09      	ldr	r3, [pc, #36]	; (8000954 <RCC_PCLK1Config+0x34>)
 800092e:	689b      	ldr	r3, [r3, #8]
 8000930:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8000932:	68fb      	ldr	r3, [r7, #12]
 8000934:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8000938:	60fb      	str	r3, [r7, #12]

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800093a:	68fa      	ldr	r2, [r7, #12]
 800093c:	687b      	ldr	r3, [r7, #4]
 800093e:	4313      	orrs	r3, r2
 8000940:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000942:	4a04      	ldr	r2, [pc, #16]	; (8000954 <RCC_PCLK1Config+0x34>)
 8000944:	68fb      	ldr	r3, [r7, #12]
 8000946:	6093      	str	r3, [r2, #8]
}
 8000948:	bf00      	nop
 800094a:	3714      	adds	r7, #20
 800094c:	46bd      	mov	sp, r7
 800094e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000952:	4770      	bx	lr
 8000954:	40023800 	.word	0x40023800

08000958 <RCC_PCLK2Config>:
  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8000958:	b480      	push	{r7}
 800095a:	b085      	sub	sp, #20
 800095c:	af00      	add	r7, sp, #0
 800095e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8000960:	2300      	movs	r3, #0
 8000962:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8000964:	4b0a      	ldr	r3, [pc, #40]	; (8000990 <RCC_PCLK2Config+0x38>)
 8000966:	689b      	ldr	r3, [r3, #8]
 8000968:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 800096a:	68fb      	ldr	r3, [r7, #12]
 800096c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000970:	60fb      	str	r3, [r7, #12]

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8000972:	687b      	ldr	r3, [r7, #4]
 8000974:	00db      	lsls	r3, r3, #3
 8000976:	68fa      	ldr	r2, [r7, #12]
 8000978:	4313      	orrs	r3, r2
 800097a:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800097c:	4a04      	ldr	r2, [pc, #16]	; (8000990 <RCC_PCLK2Config+0x38>)
 800097e:	68fb      	ldr	r3, [r7, #12]
 8000980:	6093      	str	r3, [r2, #8]
}
 8000982:	bf00      	nop
 8000984:	3714      	adds	r7, #20
 8000986:	46bd      	mov	sp, r7
 8000988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800098c:	4770      	bx	lr
 800098e:	bf00      	nop
 8000990:	40023800 	.word	0x40023800

08000994 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8000994:	b480      	push	{r7}
 8000996:	b089      	sub	sp, #36	; 0x24
 8000998:	af00      	add	r7, sp, #0
 800099a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 800099c:	2300      	movs	r3, #0
 800099e:	61bb      	str	r3, [r7, #24]
 80009a0:	2300      	movs	r3, #0
 80009a2:	617b      	str	r3, [r7, #20]
 80009a4:	2300      	movs	r3, #0
 80009a6:	61fb      	str	r3, [r7, #28]
 80009a8:	2302      	movs	r3, #2
 80009aa:	613b      	str	r3, [r7, #16]
 80009ac:	2300      	movs	r3, #0
 80009ae:	60fb      	str	r3, [r7, #12]
 80009b0:	2302      	movs	r3, #2
 80009b2:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80009b4:	4b48      	ldr	r3, [pc, #288]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 80009b6:	689b      	ldr	r3, [r3, #8]
 80009b8:	f003 030c 	and.w	r3, r3, #12
 80009bc:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 80009be:	69bb      	ldr	r3, [r7, #24]
 80009c0:	2b04      	cmp	r3, #4
 80009c2:	d007      	beq.n	80009d4 <RCC_GetClocksFreq+0x40>
 80009c4:	2b08      	cmp	r3, #8
 80009c6:	d009      	beq.n	80009dc <RCC_GetClocksFreq+0x48>
 80009c8:	2b00      	cmp	r3, #0
 80009ca:	d13f      	bne.n	8000a4c <RCC_GetClocksFreq+0xb8>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80009cc:	687b      	ldr	r3, [r7, #4]
 80009ce:	4a43      	ldr	r2, [pc, #268]	; (8000adc <RCC_GetClocksFreq+0x148>)
 80009d0:	601a      	str	r2, [r3, #0]
      break;
 80009d2:	e03f      	b.n	8000a54 <RCC_GetClocksFreq+0xc0>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80009d4:	687b      	ldr	r3, [r7, #4]
 80009d6:	4a42      	ldr	r2, [pc, #264]	; (8000ae0 <RCC_GetClocksFreq+0x14c>)
 80009d8:	601a      	str	r2, [r3, #0]
      break;
 80009da:	e03b      	b.n	8000a54 <RCC_GetClocksFreq+0xc0>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80009dc:	4b3e      	ldr	r3, [pc, #248]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 80009de:	685b      	ldr	r3, [r3, #4]
 80009e0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80009e4:	0d9b      	lsrs	r3, r3, #22
 80009e6:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80009e8:	4b3b      	ldr	r3, [pc, #236]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 80009ea:	685b      	ldr	r3, [r3, #4]
 80009ec:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80009f0:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 80009f2:	68fb      	ldr	r3, [r7, #12]
 80009f4:	2b00      	cmp	r3, #0
 80009f6:	d00d      	beq.n	8000a14 <RCC_GetClocksFreq+0x80>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80009f8:	4a39      	ldr	r2, [pc, #228]	; (8000ae0 <RCC_GetClocksFreq+0x14c>)
 80009fa:	68bb      	ldr	r3, [r7, #8]
 80009fc:	fbb2 f2f3 	udiv	r2, r2, r3
 8000a00:	4b35      	ldr	r3, [pc, #212]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000a02:	6859      	ldr	r1, [r3, #4]
 8000a04:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8000a08:	400b      	ands	r3, r1
 8000a0a:	099b      	lsrs	r3, r3, #6
 8000a0c:	fb03 f302 	mul.w	r3, r3, r2
 8000a10:	61fb      	str	r3, [r7, #28]
 8000a12:	e00c      	b.n	8000a2e <RCC_GetClocksFreq+0x9a>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8000a14:	4a31      	ldr	r2, [pc, #196]	; (8000adc <RCC_GetClocksFreq+0x148>)
 8000a16:	68bb      	ldr	r3, [r7, #8]
 8000a18:	fbb2 f2f3 	udiv	r2, r2, r3
 8000a1c:	4b2e      	ldr	r3, [pc, #184]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000a1e:	6859      	ldr	r1, [r3, #4]
 8000a20:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8000a24:	400b      	ands	r3, r1
 8000a26:	099b      	lsrs	r3, r3, #6
 8000a28:	fb03 f302 	mul.w	r3, r3, r2
 8000a2c:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000a2e:	4b2a      	ldr	r3, [pc, #168]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000a30:	685b      	ldr	r3, [r3, #4]
 8000a32:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8000a36:	0c1b      	lsrs	r3, r3, #16
 8000a38:	3301      	adds	r3, #1
 8000a3a:	005b      	lsls	r3, r3, #1
 8000a3c:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8000a3e:	69fa      	ldr	r2, [r7, #28]
 8000a40:	693b      	ldr	r3, [r7, #16]
 8000a42:	fbb2 f2f3 	udiv	r2, r2, r3
 8000a46:	687b      	ldr	r3, [r7, #4]
 8000a48:	601a      	str	r2, [r3, #0]
      break;
 8000a4a:	e003      	b.n	8000a54 <RCC_GetClocksFreq+0xc0>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8000a4c:	687b      	ldr	r3, [r7, #4]
 8000a4e:	4a23      	ldr	r2, [pc, #140]	; (8000adc <RCC_GetClocksFreq+0x148>)
 8000a50:	601a      	str	r2, [r3, #0]
      break;
 8000a52:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8000a54:	4b20      	ldr	r3, [pc, #128]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000a56:	689b      	ldr	r3, [r3, #8]
 8000a58:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000a5c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8000a5e:	69bb      	ldr	r3, [r7, #24]
 8000a60:	091b      	lsrs	r3, r3, #4
 8000a62:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8000a64:	4a1f      	ldr	r2, [pc, #124]	; (8000ae4 <RCC_GetClocksFreq+0x150>)
 8000a66:	69bb      	ldr	r3, [r7, #24]
 8000a68:	4413      	add	r3, r2
 8000a6a:	781b      	ldrb	r3, [r3, #0]
 8000a6c:	b2db      	uxtb	r3, r3
 8000a6e:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8000a70:	687b      	ldr	r3, [r7, #4]
 8000a72:	681a      	ldr	r2, [r3, #0]
 8000a74:	697b      	ldr	r3, [r7, #20]
 8000a76:	40da      	lsrs	r2, r3
 8000a78:	687b      	ldr	r3, [r7, #4]
 8000a7a:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8000a7c:	4b16      	ldr	r3, [pc, #88]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000a7e:	689b      	ldr	r3, [r3, #8]
 8000a80:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8000a84:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 8000a86:	69bb      	ldr	r3, [r7, #24]
 8000a88:	0a9b      	lsrs	r3, r3, #10
 8000a8a:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8000a8c:	4a15      	ldr	r2, [pc, #84]	; (8000ae4 <RCC_GetClocksFreq+0x150>)
 8000a8e:	69bb      	ldr	r3, [r7, #24]
 8000a90:	4413      	add	r3, r2
 8000a92:	781b      	ldrb	r3, [r3, #0]
 8000a94:	b2db      	uxtb	r3, r3
 8000a96:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000a98:	687b      	ldr	r3, [r7, #4]
 8000a9a:	685a      	ldr	r2, [r3, #4]
 8000a9c:	697b      	ldr	r3, [r7, #20]
 8000a9e:	40da      	lsrs	r2, r3
 8000aa0:	687b      	ldr	r3, [r7, #4]
 8000aa2:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8000aa4:	4b0c      	ldr	r3, [pc, #48]	; (8000ad8 <RCC_GetClocksFreq+0x144>)
 8000aa6:	689b      	ldr	r3, [r3, #8]
 8000aa8:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000aac:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 8000aae:	69bb      	ldr	r3, [r7, #24]
 8000ab0:	0b5b      	lsrs	r3, r3, #13
 8000ab2:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8000ab4:	4a0b      	ldr	r2, [pc, #44]	; (8000ae4 <RCC_GetClocksFreq+0x150>)
 8000ab6:	69bb      	ldr	r3, [r7, #24]
 8000ab8:	4413      	add	r3, r2
 8000aba:	781b      	ldrb	r3, [r3, #0]
 8000abc:	b2db      	uxtb	r3, r3
 8000abe:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000ac0:	687b      	ldr	r3, [r7, #4]
 8000ac2:	685a      	ldr	r2, [r3, #4]
 8000ac4:	697b      	ldr	r3, [r7, #20]
 8000ac6:	40da      	lsrs	r2, r3
 8000ac8:	687b      	ldr	r3, [r7, #4]
 8000aca:	60da      	str	r2, [r3, #12]
}
 8000acc:	bf00      	nop
 8000ace:	3724      	adds	r7, #36	; 0x24
 8000ad0:	46bd      	mov	sp, r7
 8000ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ad6:	4770      	bx	lr
 8000ad8:	40023800 	.word	0x40023800
 8000adc:	00f42400 	.word	0x00f42400
 8000ae0:	007a1200 	.word	0x007a1200
 8000ae4:	20000000 	.word	0x20000000

08000ae8 <RCC_RTCCLKConfig>:
  *         RTC clock source).
  *  
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 8000ae8:	b480      	push	{r7}
 8000aea:	b085      	sub	sp, #20
 8000aec:	af00      	add	r7, sp, #0
 8000aee:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8000af0:	2300      	movs	r3, #0
 8000af2:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8000af4:	687b      	ldr	r3, [r7, #4]
 8000af6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000afa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8000afe:	d111      	bne.n	8000b24 <RCC_RTCCLKConfig+0x3c>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8000b00:	4b0f      	ldr	r3, [pc, #60]	; (8000b40 <RCC_RTCCLKConfig+0x58>)
 8000b02:	689b      	ldr	r3, [r3, #8]
 8000b04:	60fb      	str	r3, [r7, #12]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8000b06:	68fb      	ldr	r3, [r7, #12]
 8000b08:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8000b0c:	60fb      	str	r3, [r7, #12]

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8000b0e:	687b      	ldr	r3, [r7, #4]
 8000b10:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8000b14:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000b18:	68fa      	ldr	r2, [r7, #12]
 8000b1a:	4313      	orrs	r3, r2
 8000b1c:	60fb      	str	r3, [r7, #12]

    /* Store the new value */
    RCC->CFGR = tmpreg;
 8000b1e:	4a08      	ldr	r2, [pc, #32]	; (8000b40 <RCC_RTCCLKConfig+0x58>)
 8000b20:	68fb      	ldr	r3, [r7, #12]
 8000b22:	6093      	str	r3, [r2, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8000b24:	4906      	ldr	r1, [pc, #24]	; (8000b40 <RCC_RTCCLKConfig+0x58>)
 8000b26:	4b06      	ldr	r3, [pc, #24]	; (8000b40 <RCC_RTCCLKConfig+0x58>)
 8000b28:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8000b2a:	687b      	ldr	r3, [r7, #4]
 8000b2c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8000b30:	4313      	orrs	r3, r2
 8000b32:	670b      	str	r3, [r1, #112]	; 0x70
}
 8000b34:	bf00      	nop
 8000b36:	3714      	adds	r7, #20
 8000b38:	46bd      	mov	sp, r7
 8000b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b3e:	4770      	bx	lr
 8000b40:	40023800 	.word	0x40023800

08000b44 <RCC_RTCCLKCmd>:
  *         using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 8000b44:	b480      	push	{r7}
 8000b46:	b083      	sub	sp, #12
 8000b48:	af00      	add	r7, sp, #0
 8000b4a:	4603      	mov	r3, r0
 8000b4c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8000b4e:	4a04      	ldr	r2, [pc, #16]	; (8000b60 <RCC_RTCCLKCmd+0x1c>)
 8000b50:	79fb      	ldrb	r3, [r7, #7]
 8000b52:	6013      	str	r3, [r2, #0]
}
 8000b54:	bf00      	nop
 8000b56:	370c      	adds	r7, #12
 8000b58:	46bd      	mov	sp, r7
 8000b5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b5e:	4770      	bx	lr
 8000b60:	42470e3c 	.word	0x42470e3c

08000b64 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8000b64:	b480      	push	{r7}
 8000b66:	b083      	sub	sp, #12
 8000b68:	af00      	add	r7, sp, #0
 8000b6a:	6078      	str	r0, [r7, #4]
 8000b6c:	460b      	mov	r3, r1
 8000b6e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000b70:	78fb      	ldrb	r3, [r7, #3]
 8000b72:	2b00      	cmp	r3, #0
 8000b74:	d006      	beq.n	8000b84 <RCC_AHB1PeriphClockCmd+0x20>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8000b76:	490a      	ldr	r1, [pc, #40]	; (8000ba0 <RCC_AHB1PeriphClockCmd+0x3c>)
 8000b78:	4b09      	ldr	r3, [pc, #36]	; (8000ba0 <RCC_AHB1PeriphClockCmd+0x3c>)
 8000b7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000b7c:	687b      	ldr	r3, [r7, #4]
 8000b7e:	4313      	orrs	r3, r2
 8000b80:	630b      	str	r3, [r1, #48]	; 0x30
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  }
}
 8000b82:	e006      	b.n	8000b92 <RCC_AHB1PeriphClockCmd+0x2e>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8000b84:	4906      	ldr	r1, [pc, #24]	; (8000ba0 <RCC_AHB1PeriphClockCmd+0x3c>)
 8000b86:	4b06      	ldr	r3, [pc, #24]	; (8000ba0 <RCC_AHB1PeriphClockCmd+0x3c>)
 8000b88:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000b8a:	687b      	ldr	r3, [r7, #4]
 8000b8c:	43db      	mvns	r3, r3
 8000b8e:	4013      	ands	r3, r2
 8000b90:	630b      	str	r3, [r1, #48]	; 0x30
  }
}
 8000b92:	bf00      	nop
 8000b94:	370c      	adds	r7, #12
 8000b96:	46bd      	mov	sp, r7
 8000b98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b9c:	4770      	bx	lr
 8000b9e:	bf00      	nop
 8000ba0:	40023800 	.word	0x40023800

08000ba4 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8000ba4:	b480      	push	{r7}
 8000ba6:	b083      	sub	sp, #12
 8000ba8:	af00      	add	r7, sp, #0
 8000baa:	6078      	str	r0, [r7, #4]
 8000bac:	460b      	mov	r3, r1
 8000bae:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000bb0:	78fb      	ldrb	r3, [r7, #3]
 8000bb2:	2b00      	cmp	r3, #0
 8000bb4:	d006      	beq.n	8000bc4 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8000bb6:	490a      	ldr	r1, [pc, #40]	; (8000be0 <RCC_APB1PeriphClockCmd+0x3c>)
 8000bb8:	4b09      	ldr	r3, [pc, #36]	; (8000be0 <RCC_APB1PeriphClockCmd+0x3c>)
 8000bba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000bbc:	687b      	ldr	r3, [r7, #4]
 8000bbe:	4313      	orrs	r3, r2
 8000bc0:	640b      	str	r3, [r1, #64]	; 0x40
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 8000bc2:	e006      	b.n	8000bd2 <RCC_APB1PeriphClockCmd+0x2e>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8000bc4:	4906      	ldr	r1, [pc, #24]	; (8000be0 <RCC_APB1PeriphClockCmd+0x3c>)
 8000bc6:	4b06      	ldr	r3, [pc, #24]	; (8000be0 <RCC_APB1PeriphClockCmd+0x3c>)
 8000bc8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000bca:	687b      	ldr	r3, [r7, #4]
 8000bcc:	43db      	mvns	r3, r3
 8000bce:	4013      	ands	r3, r2
 8000bd0:	640b      	str	r3, [r1, #64]	; 0x40
  }
}
 8000bd2:	bf00      	nop
 8000bd4:	370c      	adds	r7, #12
 8000bd6:	46bd      	mov	sp, r7
 8000bd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bdc:	4770      	bx	lr
 8000bde:	bf00      	nop
 8000be0:	40023800 	.word	0x40023800

08000be4 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8000be4:	b480      	push	{r7}
 8000be6:	b083      	sub	sp, #12
 8000be8:	af00      	add	r7, sp, #0
 8000bea:	6078      	str	r0, [r7, #4]
 8000bec:	460b      	mov	r3, r1
 8000bee:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000bf0:	78fb      	ldrb	r3, [r7, #3]
 8000bf2:	2b00      	cmp	r3, #0
 8000bf4:	d006      	beq.n	8000c04 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8000bf6:	490a      	ldr	r1, [pc, #40]	; (8000c20 <RCC_APB2PeriphClockCmd+0x3c>)
 8000bf8:	4b09      	ldr	r3, [pc, #36]	; (8000c20 <RCC_APB2PeriphClockCmd+0x3c>)
 8000bfa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bfc:	687b      	ldr	r3, [r7, #4]
 8000bfe:	4313      	orrs	r3, r2
 8000c00:	644b      	str	r3, [r1, #68]	; 0x44
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 8000c02:	e006      	b.n	8000c12 <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8000c04:	4906      	ldr	r1, [pc, #24]	; (8000c20 <RCC_APB2PeriphClockCmd+0x3c>)
 8000c06:	4b06      	ldr	r3, [pc, #24]	; (8000c20 <RCC_APB2PeriphClockCmd+0x3c>)
 8000c08:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000c0a:	687b      	ldr	r3, [r7, #4]
 8000c0c:	43db      	mvns	r3, r3
 8000c0e:	4013      	ands	r3, r2
 8000c10:	644b      	str	r3, [r1, #68]	; 0x44
  }
}
 8000c12:	bf00      	nop
 8000c14:	370c      	adds	r7, #12
 8000c16:	46bd      	mov	sp, r7
 8000c18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c1c:	4770      	bx	lr
 8000c1e:	bf00      	nop
 8000c20:	40023800 	.word	0x40023800

08000c24 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8000c24:	b480      	push	{r7}
 8000c26:	b083      	sub	sp, #12
 8000c28:	af00      	add	r7, sp, #0
 8000c2a:	6078      	str	r0, [r7, #4]
 8000c2c:	460b      	mov	r3, r1
 8000c2e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000c30:	78fb      	ldrb	r3, [r7, #3]
 8000c32:	2b00      	cmp	r3, #0
 8000c34:	d006      	beq.n	8000c44 <RCC_APB1PeriphResetCmd+0x20>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8000c36:	490a      	ldr	r1, [pc, #40]	; (8000c60 <RCC_APB1PeriphResetCmd+0x3c>)
 8000c38:	4b09      	ldr	r3, [pc, #36]	; (8000c60 <RCC_APB1PeriphResetCmd+0x3c>)
 8000c3a:	6a1a      	ldr	r2, [r3, #32]
 8000c3c:	687b      	ldr	r3, [r7, #4]
 8000c3e:	4313      	orrs	r3, r2
 8000c40:	620b      	str	r3, [r1, #32]
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  }
}
 8000c42:	e006      	b.n	8000c52 <RCC_APB1PeriphResetCmd+0x2e>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8000c44:	4906      	ldr	r1, [pc, #24]	; (8000c60 <RCC_APB1PeriphResetCmd+0x3c>)
 8000c46:	4b06      	ldr	r3, [pc, #24]	; (8000c60 <RCC_APB1PeriphResetCmd+0x3c>)
 8000c48:	6a1a      	ldr	r2, [r3, #32]
 8000c4a:	687b      	ldr	r3, [r7, #4]
 8000c4c:	43db      	mvns	r3, r3
 8000c4e:	4013      	ands	r3, r2
 8000c50:	620b      	str	r3, [r1, #32]
  }
}
 8000c52:	bf00      	nop
 8000c54:	370c      	adds	r7, #12
 8000c56:	46bd      	mov	sp, r7
 8000c58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c5c:	4770      	bx	lr
 8000c5e:	bf00      	nop
 8000c60:	40023800 	.word	0x40023800

08000c64 <RCC_GetFlagStatus>:
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *            @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 8000c64:	b480      	push	{r7}
 8000c66:	b087      	sub	sp, #28
 8000c68:	af00      	add	r7, sp, #0
 8000c6a:	4603      	mov	r3, r0
 8000c6c:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 8000c6e:	2300      	movs	r3, #0
 8000c70:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 8000c72:	2300      	movs	r3, #0
 8000c74:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 8000c76:	2300      	movs	r3, #0
 8000c78:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8000c7a:	79fb      	ldrb	r3, [r7, #7]
 8000c7c:	095b      	lsrs	r3, r3, #5
 8000c7e:	b2db      	uxtb	r3, r3
 8000c80:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 8000c82:	68fb      	ldr	r3, [r7, #12]
 8000c84:	2b01      	cmp	r3, #1
 8000c86:	d103      	bne.n	8000c90 <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
 8000c88:	4b12      	ldr	r3, [pc, #72]	; (8000cd4 <RCC_GetFlagStatus+0x70>)
 8000c8a:	681b      	ldr	r3, [r3, #0]
 8000c8c:	617b      	str	r3, [r7, #20]
 8000c8e:	e009      	b.n	8000ca4 <RCC_GetFlagStatus+0x40>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8000c90:	68fb      	ldr	r3, [r7, #12]
 8000c92:	2b02      	cmp	r3, #2
 8000c94:	d103      	bne.n	8000c9e <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->BDCR;
 8000c96:	4b0f      	ldr	r3, [pc, #60]	; (8000cd4 <RCC_GetFlagStatus+0x70>)
 8000c98:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8000c9a:	617b      	str	r3, [r7, #20]
 8000c9c:	e002      	b.n	8000ca4 <RCC_GetFlagStatus+0x40>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8000c9e:	4b0d      	ldr	r3, [pc, #52]	; (8000cd4 <RCC_GetFlagStatus+0x70>)
 8000ca0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000ca2:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8000ca4:	79fb      	ldrb	r3, [r7, #7]
 8000ca6:	f003 031f 	and.w	r3, r3, #31
 8000caa:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8000cac:	697a      	ldr	r2, [r7, #20]
 8000cae:	68fb      	ldr	r3, [r7, #12]
 8000cb0:	fa22 f303 	lsr.w	r3, r2, r3
 8000cb4:	f003 0301 	and.w	r3, r3, #1
 8000cb8:	2b00      	cmp	r3, #0
 8000cba:	d002      	beq.n	8000cc2 <RCC_GetFlagStatus+0x5e>
  {
    bitstatus = SET;
 8000cbc:	2301      	movs	r3, #1
 8000cbe:	74fb      	strb	r3, [r7, #19]
 8000cc0:	e001      	b.n	8000cc6 <RCC_GetFlagStatus+0x62>
  }
  else
  {
    bitstatus = RESET;
 8000cc2:	2300      	movs	r3, #0
 8000cc4:	74fb      	strb	r3, [r7, #19]
  }
  /* Return the flag status */
  return bitstatus;
 8000cc6:	7cfb      	ldrb	r3, [r7, #19]
}
 8000cc8:	4618      	mov	r0, r3
 8000cca:	371c      	adds	r7, #28
 8000ccc:	46bd      	mov	sp, r7
 8000cce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cd2:	4770      	bx	lr
 8000cd4:	40023800 	.word	0x40023800

08000cd8 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 8000cd8:	b580      	push	{r7, lr}
 8000cda:	b084      	sub	sp, #16
 8000cdc:	af00      	add	r7, sp, #0
 8000cde:	6078      	str	r0, [r7, #4]
  ErrorStatus status = ERROR;
 8000ce0:	2300      	movs	r3, #0
 8000ce2:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8000ce4:	4b19      	ldr	r3, [pc, #100]	; (8000d4c <RTC_Init+0x74>)
 8000ce6:	22ca      	movs	r2, #202	; 0xca
 8000ce8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8000cea:	4b18      	ldr	r3, [pc, #96]	; (8000d4c <RTC_Init+0x74>)
 8000cec:	2253      	movs	r2, #83	; 0x53
 8000cee:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8000cf0:	f000 f848 	bl	8000d84 <RTC_EnterInitMode>
 8000cf4:	4603      	mov	r3, r0
 8000cf6:	2b00      	cmp	r3, #0
 8000cf8:	d102      	bne.n	8000d00 <RTC_Init+0x28>
  {
    status = ERROR;
 8000cfa:	2300      	movs	r3, #0
 8000cfc:	73fb      	strb	r3, [r7, #15]
 8000cfe:	e01c      	b.n	8000d3a <RTC_Init+0x62>
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 8000d00:	4a12      	ldr	r2, [pc, #72]	; (8000d4c <RTC_Init+0x74>)
 8000d02:	4b12      	ldr	r3, [pc, #72]	; (8000d4c <RTC_Init+0x74>)
 8000d04:	689b      	ldr	r3, [r3, #8]
 8000d06:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000d0a:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 8000d0c:	490f      	ldr	r1, [pc, #60]	; (8000d4c <RTC_Init+0x74>)
 8000d0e:	4b0f      	ldr	r3, [pc, #60]	; (8000d4c <RTC_Init+0x74>)
 8000d10:	689a      	ldr	r2, [r3, #8]
 8000d12:	687b      	ldr	r3, [r7, #4]
 8000d14:	681b      	ldr	r3, [r3, #0]
 8000d16:	4313      	orrs	r3, r2
 8000d18:	608b      	str	r3, [r1, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 8000d1a:	4a0c      	ldr	r2, [pc, #48]	; (8000d4c <RTC_Init+0x74>)
 8000d1c:	687b      	ldr	r3, [r7, #4]
 8000d1e:	689b      	ldr	r3, [r3, #8]
 8000d20:	6113      	str	r3, [r2, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 8000d22:	490a      	ldr	r1, [pc, #40]	; (8000d4c <RTC_Init+0x74>)
 8000d24:	4b09      	ldr	r3, [pc, #36]	; (8000d4c <RTC_Init+0x74>)
 8000d26:	691a      	ldr	r2, [r3, #16]
 8000d28:	687b      	ldr	r3, [r7, #4]
 8000d2a:	685b      	ldr	r3, [r3, #4]
 8000d2c:	041b      	lsls	r3, r3, #16
 8000d2e:	4313      	orrs	r3, r2
 8000d30:	610b      	str	r3, [r1, #16]

    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8000d32:	f000 f861 	bl	8000df8 <RTC_ExitInitMode>

    status = SUCCESS;    
 8000d36:	2301      	movs	r3, #1
 8000d38:	73fb      	strb	r3, [r7, #15]
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8000d3a:	4b04      	ldr	r3, [pc, #16]	; (8000d4c <RTC_Init+0x74>)
 8000d3c:	22ff      	movs	r2, #255	; 0xff
 8000d3e:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8000d40:	7bfb      	ldrb	r3, [r7, #15]
}
 8000d42:	4618      	mov	r0, r3
 8000d44:	3710      	adds	r7, #16
 8000d46:	46bd      	mov	sp, r7
 8000d48:	bd80      	pop	{r7, pc}
 8000d4a:	bf00      	nop
 8000d4c:	40002800 	.word	0x40002800

08000d50 <RTC_WriteProtectionCmd>:
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
 8000d50:	b480      	push	{r7}
 8000d52:	b083      	sub	sp, #12
 8000d54:	af00      	add	r7, sp, #0
 8000d56:	4603      	mov	r3, r0
 8000d58:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8000d5a:	79fb      	ldrb	r3, [r7, #7]
 8000d5c:	2b00      	cmp	r3, #0
 8000d5e:	d003      	beq.n	8000d68 <RTC_WriteProtectionCmd+0x18>
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
 8000d60:	4b07      	ldr	r3, [pc, #28]	; (8000d80 <RTC_WriteProtectionCmd+0x30>)
 8000d62:	22ff      	movs	r2, #255	; 0xff
 8000d64:	625a      	str	r2, [r3, #36]	; 0x24
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
    RTC->WPR = 0x53;    
  }
}
 8000d66:	e005      	b.n	8000d74 <RTC_WriteProtectionCmd+0x24>
    RTC->WPR = 0xFF;   
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 8000d68:	4b05      	ldr	r3, [pc, #20]	; (8000d80 <RTC_WriteProtectionCmd+0x30>)
 8000d6a:	22ca      	movs	r2, #202	; 0xca
 8000d6c:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 8000d6e:	4b04      	ldr	r3, [pc, #16]	; (8000d80 <RTC_WriteProtectionCmd+0x30>)
 8000d70:	2253      	movs	r2, #83	; 0x53
 8000d72:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 8000d74:	bf00      	nop
 8000d76:	370c      	adds	r7, #12
 8000d78:	46bd      	mov	sp, r7
 8000d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d7e:	4770      	bx	lr
 8000d80:	40002800 	.word	0x40002800

08000d84 <RTC_EnterInitMode>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
 8000d84:	b480      	push	{r7}
 8000d86:	b085      	sub	sp, #20
 8000d88:	af00      	add	r7, sp, #0
  __IO uint32_t initcounter = 0x00;
 8000d8a:	2300      	movs	r3, #0
 8000d8c:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 8000d8e:	2300      	movs	r3, #0
 8000d90:	73fb      	strb	r3, [r7, #15]
  uint32_t initstatus = 0x00;
 8000d92:	2300      	movs	r3, #0
 8000d94:	60bb      	str	r3, [r7, #8]
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8000d96:	4b17      	ldr	r3, [pc, #92]	; (8000df4 <RTC_EnterInitMode+0x70>)
 8000d98:	68db      	ldr	r3, [r3, #12]
 8000d9a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000d9e:	2b00      	cmp	r3, #0
 8000da0:	d11e      	bne.n	8000de0 <RTC_EnterInitMode+0x5c>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 8000da2:	4b14      	ldr	r3, [pc, #80]	; (8000df4 <RTC_EnterInitMode+0x70>)
 8000da4:	f04f 32ff 	mov.w	r2, #4294967295
 8000da8:	60da      	str	r2, [r3, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 8000daa:	4b12      	ldr	r3, [pc, #72]	; (8000df4 <RTC_EnterInitMode+0x70>)
 8000dac:	68db      	ldr	r3, [r3, #12]
 8000dae:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000db2:	60bb      	str	r3, [r7, #8]
      initcounter++;  
 8000db4:	687b      	ldr	r3, [r7, #4]
 8000db6:	3301      	adds	r3, #1
 8000db8:	607b      	str	r3, [r7, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8000dba:	687b      	ldr	r3, [r7, #4]
 8000dbc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000dc0:	d002      	beq.n	8000dc8 <RTC_EnterInitMode+0x44>
 8000dc2:	68bb      	ldr	r3, [r7, #8]
 8000dc4:	2b00      	cmp	r3, #0
 8000dc6:	d0f0      	beq.n	8000daa <RTC_EnterInitMode+0x26>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 8000dc8:	4b0a      	ldr	r3, [pc, #40]	; (8000df4 <RTC_EnterInitMode+0x70>)
 8000dca:	68db      	ldr	r3, [r3, #12]
 8000dcc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000dd0:	2b00      	cmp	r3, #0
 8000dd2:	d002      	beq.n	8000dda <RTC_EnterInitMode+0x56>
    {
      status = SUCCESS;
 8000dd4:	2301      	movs	r3, #1
 8000dd6:	73fb      	strb	r3, [r7, #15]
 8000dd8:	e004      	b.n	8000de4 <RTC_EnterInitMode+0x60>
    }
    else
    {
      status = ERROR;
 8000dda:	2300      	movs	r3, #0
 8000ddc:	73fb      	strb	r3, [r7, #15]
 8000dde:	e001      	b.n	8000de4 <RTC_EnterInitMode+0x60>
    }        
  }
  else
  {
    status = SUCCESS;  
 8000de0:	2301      	movs	r3, #1
 8000de2:	73fb      	strb	r3, [r7, #15]
  } 
    
  return (status);  
 8000de4:	7bfb      	ldrb	r3, [r7, #15]
}
 8000de6:	4618      	mov	r0, r3
 8000de8:	3714      	adds	r7, #20
 8000dea:	46bd      	mov	sp, r7
 8000dec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000df0:	4770      	bx	lr
 8000df2:	bf00      	nop
 8000df4:	40002800 	.word	0x40002800

08000df8 <RTC_ExitInitMode>:
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
 8000df8:	b480      	push	{r7}
 8000dfa:	af00      	add	r7, sp, #0
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8000dfc:	4a05      	ldr	r2, [pc, #20]	; (8000e14 <RTC_ExitInitMode+0x1c>)
 8000dfe:	4b05      	ldr	r3, [pc, #20]	; (8000e14 <RTC_ExitInitMode+0x1c>)
 8000e00:	68db      	ldr	r3, [r3, #12]
 8000e02:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000e06:	60d3      	str	r3, [r2, #12]
}
 8000e08:	bf00      	nop
 8000e0a:	46bd      	mov	sp, r7
 8000e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e10:	4770      	bx	lr
 8000e12:	bf00      	nop
 8000e14:	40002800 	.word	0x40002800

08000e18 <RTC_WaitForSynchro>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 8000e18:	b480      	push	{r7}
 8000e1a:	b085      	sub	sp, #20
 8000e1c:	af00      	add	r7, sp, #0
  __IO uint32_t synchrocounter = 0;
 8000e1e:	2300      	movs	r3, #0
 8000e20:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 8000e22:	2300      	movs	r3, #0
 8000e24:	73fb      	strb	r3, [r7, #15]
  uint32_t synchrostatus = 0x00;
 8000e26:	2300      	movs	r3, #0
 8000e28:	60bb      	str	r3, [r7, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8000e2a:	4b18      	ldr	r3, [pc, #96]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e2c:	22ca      	movs	r2, #202	; 0xca
 8000e2e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8000e30:	4b16      	ldr	r3, [pc, #88]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e32:	2253      	movs	r2, #83	; 0x53
 8000e34:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8000e36:	4a15      	ldr	r2, [pc, #84]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e38:	4b14      	ldr	r3, [pc, #80]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e3a:	68db      	ldr	r3, [r3, #12]
 8000e3c:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8000e40:	60d3      	str	r3, [r2, #12]
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8000e42:	4b12      	ldr	r3, [pc, #72]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e44:	68db      	ldr	r3, [r3, #12]
 8000e46:	f003 0320 	and.w	r3, r3, #32
 8000e4a:	60bb      	str	r3, [r7, #8]
    synchrocounter++;  
 8000e4c:	687b      	ldr	r3, [r7, #4]
 8000e4e:	3301      	adds	r3, #1
 8000e50:	607b      	str	r3, [r7, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8000e52:	687b      	ldr	r3, [r7, #4]
 8000e54:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8000e58:	d002      	beq.n	8000e60 <RTC_WaitForSynchro+0x48>
 8000e5a:	68bb      	ldr	r3, [r7, #8]
 8000e5c:	2b00      	cmp	r3, #0
 8000e5e:	d0f0      	beq.n	8000e42 <RTC_WaitForSynchro+0x2a>
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 8000e60:	4b0a      	ldr	r3, [pc, #40]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e62:	68db      	ldr	r3, [r3, #12]
 8000e64:	f003 0320 	and.w	r3, r3, #32
 8000e68:	2b00      	cmp	r3, #0
 8000e6a:	d002      	beq.n	8000e72 <RTC_WaitForSynchro+0x5a>
  {
    status = SUCCESS;
 8000e6c:	2301      	movs	r3, #1
 8000e6e:	73fb      	strb	r3, [r7, #15]
 8000e70:	e001      	b.n	8000e76 <RTC_WaitForSynchro+0x5e>
  }
  else
  {
    status = ERROR;
 8000e72:	2300      	movs	r3, #0
 8000e74:	73fb      	strb	r3, [r7, #15]
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8000e76:	4b05      	ldr	r3, [pc, #20]	; (8000e8c <RTC_WaitForSynchro+0x74>)
 8000e78:	22ff      	movs	r2, #255	; 0xff
 8000e7a:	625a      	str	r2, [r3, #36]	; 0x24
    
  return (status); 
 8000e7c:	7bfb      	ldrb	r3, [r7, #15]
}
 8000e7e:	4618      	mov	r0, r3
 8000e80:	3714      	adds	r7, #20
 8000e82:	46bd      	mov	sp, r7
 8000e84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e88:	4770      	bx	lr
 8000e8a:	bf00      	nop
 8000e8c:	40002800 	.word	0x40002800

08000e90 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8000e90:	b590      	push	{r4, r7, lr}
 8000e92:	b085      	sub	sp, #20
 8000e94:	af00      	add	r7, sp, #0
 8000e96:	6078      	str	r0, [r7, #4]
 8000e98:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8000e9a:	2300      	movs	r3, #0
 8000e9c:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8000e9e:	2300      	movs	r3, #0
 8000ea0:	72fb      	strb	r3, [r7, #11]
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 8000ea2:	687b      	ldr	r3, [r7, #4]
 8000ea4:	2b00      	cmp	r3, #0
 8000ea6:	d109      	bne.n	8000ebc <RTC_SetTime+0x2c>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8000ea8:	4b3d      	ldr	r3, [pc, #244]	; (8000fa0 <RTC_SetTime+0x110>)
 8000eaa:	689b      	ldr	r3, [r3, #8]
 8000eac:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000eb0:	2b00      	cmp	r3, #0
 8000eb2:	d114      	bne.n	8000ede <RTC_SetTime+0x4e>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8000eb4:	683b      	ldr	r3, [r7, #0]
 8000eb6:	2200      	movs	r2, #0
 8000eb8:	70da      	strb	r2, [r3, #3]
 8000eba:	e010      	b.n	8000ede <RTC_SetTime+0x4e>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8000ebc:	4b38      	ldr	r3, [pc, #224]	; (8000fa0 <RTC_SetTime+0x110>)
 8000ebe:	689b      	ldr	r3, [r3, #8]
 8000ec0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000ec4:	2b00      	cmp	r3, #0
 8000ec6:	d007      	beq.n	8000ed8 <RTC_SetTime+0x48>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8000ec8:	683b      	ldr	r3, [r7, #0]
 8000eca:	781b      	ldrb	r3, [r3, #0]
 8000ecc:	4618      	mov	r0, r3
 8000ece:	f000 fb15 	bl	80014fc <RTC_Bcd2ToByte>
 8000ed2:	4603      	mov	r3, r0
 8000ed4:	60fb      	str	r3, [r7, #12]
 8000ed6:	e002      	b.n	8000ede <RTC_SetTime+0x4e>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8000ed8:	683b      	ldr	r3, [r7, #0]
 8000eda:	2200      	movs	r2, #0
 8000edc:	70da      	strb	r2, [r3, #3]
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8000ede:	687b      	ldr	r3, [r7, #4]
 8000ee0:	2b00      	cmp	r3, #0
 8000ee2:	d00f      	beq.n	8000f04 <RTC_SetTime+0x74>
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000ee4:	683b      	ldr	r3, [r7, #0]
 8000ee6:	781b      	ldrb	r3, [r3, #0]
 8000ee8:	041a      	lsls	r2, r3, #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8000eea:	683b      	ldr	r3, [r7, #0]
 8000eec:	785b      	ldrb	r3, [r3, #1]
 8000eee:	021b      	lsls	r3, r3, #8
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000ef0:	4313      	orrs	r3, r2
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8000ef2:	683a      	ldr	r2, [r7, #0]
 8000ef4:	7892      	ldrb	r2, [r2, #2]
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8000ef6:	431a      	orrs	r2, r3
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 8000ef8:	683b      	ldr	r3, [r7, #0]
 8000efa:	78db      	ldrb	r3, [r3, #3]
 8000efc:	041b      	lsls	r3, r3, #16
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000efe:	4313      	orrs	r3, r2
 8000f00:	60fb      	str	r3, [r7, #12]
 8000f02:	e01b      	b.n	8000f3c <RTC_SetTime+0xac>
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000f04:	683b      	ldr	r3, [r7, #0]
 8000f06:	781b      	ldrb	r3, [r3, #0]
 8000f08:	4618      	mov	r0, r3
 8000f0a:	f000 fad9 	bl	80014c0 <RTC_ByteToBcd2>
 8000f0e:	4603      	mov	r3, r0
 8000f10:	041c      	lsls	r4, r3, #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8000f12:	683b      	ldr	r3, [r7, #0]
 8000f14:	785b      	ldrb	r3, [r3, #1]
 8000f16:	4618      	mov	r0, r3
 8000f18:	f000 fad2 	bl	80014c0 <RTC_ByteToBcd2>
 8000f1c:	4603      	mov	r3, r0
 8000f1e:	021b      	lsls	r3, r3, #8
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000f20:	431c      	orrs	r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8000f22:	683b      	ldr	r3, [r7, #0]
 8000f24:	789b      	ldrb	r3, [r3, #2]
 8000f26:	4618      	mov	r0, r3
 8000f28:	f000 faca 	bl	80014c0 <RTC_ByteToBcd2>
 8000f2c:	4603      	mov	r3, r0
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8000f2e:	ea44 0203 	orr.w	r2, r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 8000f32:	683b      	ldr	r3, [r7, #0]
 8000f34:	78db      	ldrb	r3, [r3, #3]
 8000f36:	041b      	lsls	r3, r3, #16
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8000f38:	4313      	orrs	r3, r2
 8000f3a:	60fb      	str	r3, [r7, #12]
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8000f3c:	4b18      	ldr	r3, [pc, #96]	; (8000fa0 <RTC_SetTime+0x110>)
 8000f3e:	22ca      	movs	r2, #202	; 0xca
 8000f40:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8000f42:	4b17      	ldr	r3, [pc, #92]	; (8000fa0 <RTC_SetTime+0x110>)
 8000f44:	2253      	movs	r2, #83	; 0x53
 8000f46:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8000f48:	f7ff ff1c 	bl	8000d84 <RTC_EnterInitMode>
 8000f4c:	4603      	mov	r3, r0
 8000f4e:	2b00      	cmp	r3, #0
 8000f50:	d102      	bne.n	8000f58 <RTC_SetTime+0xc8>
  {
    status = ERROR;
 8000f52:	2300      	movs	r3, #0
 8000f54:	72fb      	strb	r3, [r7, #11]
 8000f56:	e01b      	b.n	8000f90 <RTC_SetTime+0x100>
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8000f58:	4a11      	ldr	r2, [pc, #68]	; (8000fa0 <RTC_SetTime+0x110>)
 8000f5a:	68fb      	ldr	r3, [r7, #12]
 8000f5c:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8000f60:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8000f64:	6013      	str	r3, [r2, #0]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8000f66:	f7ff ff47 	bl	8000df8 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8000f6a:	4b0d      	ldr	r3, [pc, #52]	; (8000fa0 <RTC_SetTime+0x110>)
 8000f6c:	689b      	ldr	r3, [r3, #8]
 8000f6e:	f003 0320 	and.w	r3, r3, #32
 8000f72:	2b00      	cmp	r3, #0
 8000f74:	d10a      	bne.n	8000f8c <RTC_SetTime+0xfc>
    {
    if(RTC_WaitForSynchro() == ERROR)
 8000f76:	f7ff ff4f 	bl	8000e18 <RTC_WaitForSynchro>
 8000f7a:	4603      	mov	r3, r0
 8000f7c:	2b00      	cmp	r3, #0
 8000f7e:	d102      	bne.n	8000f86 <RTC_SetTime+0xf6>
    {
      status = ERROR;
 8000f80:	2300      	movs	r3, #0
 8000f82:	72fb      	strb	r3, [r7, #11]
 8000f84:	e004      	b.n	8000f90 <RTC_SetTime+0x100>
    }
    else
    {
      status = SUCCESS;
 8000f86:	2301      	movs	r3, #1
 8000f88:	72fb      	strb	r3, [r7, #11]
 8000f8a:	e001      	b.n	8000f90 <RTC_SetTime+0x100>
    }
  }
    else
    {
      status = SUCCESS;
 8000f8c:	2301      	movs	r3, #1
 8000f8e:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8000f90:	4b03      	ldr	r3, [pc, #12]	; (8000fa0 <RTC_SetTime+0x110>)
 8000f92:	22ff      	movs	r2, #255	; 0xff
 8000f94:	625a      	str	r2, [r3, #36]	; 0x24
    
  return status;
 8000f96:	7afb      	ldrb	r3, [r7, #11]
}
 8000f98:	4618      	mov	r0, r3
 8000f9a:	3714      	adds	r7, #20
 8000f9c:	46bd      	mov	sp, r7
 8000f9e:	bd90      	pop	{r4, r7, pc}
 8000fa0:	40002800 	.word	0x40002800

08000fa4 <RTC_TimeStructInit>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
 8000fa4:	b480      	push	{r7}
 8000fa6:	b083      	sub	sp, #12
 8000fa8:	af00      	add	r7, sp, #0
 8000faa:	6078      	str	r0, [r7, #4]
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8000fac:	687b      	ldr	r3, [r7, #4]
 8000fae:	2200      	movs	r2, #0
 8000fb0:	70da      	strb	r2, [r3, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8000fb2:	687b      	ldr	r3, [r7, #4]
 8000fb4:	2200      	movs	r2, #0
 8000fb6:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8000fb8:	687b      	ldr	r3, [r7, #4]
 8000fba:	2200      	movs	r2, #0
 8000fbc:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8000fbe:	687b      	ldr	r3, [r7, #4]
 8000fc0:	2200      	movs	r2, #0
 8000fc2:	709a      	strb	r2, [r3, #2]
}
 8000fc4:	bf00      	nop
 8000fc6:	370c      	adds	r7, #12
 8000fc8:	46bd      	mov	sp, r7
 8000fca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fce:	4770      	bx	lr

08000fd0 <RTC_GetTime>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8000fd0:	b580      	push	{r7, lr}
 8000fd2:	b084      	sub	sp, #16
 8000fd4:	af00      	add	r7, sp, #0
 8000fd6:	6078      	str	r0, [r7, #4]
 8000fd8:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8000fda:	2300      	movs	r3, #0
 8000fdc:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8000fde:	4b24      	ldr	r3, [pc, #144]	; (8001070 <RTC_GetTime+0xa0>)
 8000fe0:	681b      	ldr	r3, [r3, #0]
 8000fe2:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8000fe6:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8000fea:	60fb      	str	r3, [r7, #12]
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8000fec:	68fb      	ldr	r3, [r7, #12]
 8000fee:	0c1b      	lsrs	r3, r3, #16
 8000ff0:	b2db      	uxtb	r3, r3
 8000ff2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8000ff6:	b2da      	uxtb	r2, r3
 8000ff8:	683b      	ldr	r3, [r7, #0]
 8000ffa:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8000ffc:	68fb      	ldr	r3, [r7, #12]
 8000ffe:	0a1b      	lsrs	r3, r3, #8
 8001000:	b2db      	uxtb	r3, r3
 8001002:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001006:	b2da      	uxtb	r2, r3
 8001008:	683b      	ldr	r3, [r7, #0]
 800100a:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 800100c:	68fb      	ldr	r3, [r7, #12]
 800100e:	b2db      	uxtb	r3, r3
 8001010:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001014:	b2da      	uxtb	r2, r3
 8001016:	683b      	ldr	r3, [r7, #0]
 8001018:	709a      	strb	r2, [r3, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 800101a:	68fb      	ldr	r3, [r7, #12]
 800101c:	0c1b      	lsrs	r3, r3, #16
 800101e:	b2db      	uxtb	r3, r3
 8001020:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001024:	b2da      	uxtb	r2, r3
 8001026:	683b      	ldr	r3, [r7, #0]
 8001028:	70da      	strb	r2, [r3, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 800102a:	687b      	ldr	r3, [r7, #4]
 800102c:	2b00      	cmp	r3, #0
 800102e:	d11a      	bne.n	8001066 <RTC_GetTime+0x96>
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8001030:	683b      	ldr	r3, [r7, #0]
 8001032:	781b      	ldrb	r3, [r3, #0]
 8001034:	4618      	mov	r0, r3
 8001036:	f000 fa61 	bl	80014fc <RTC_Bcd2ToByte>
 800103a:	4603      	mov	r3, r0
 800103c:	461a      	mov	r2, r3
 800103e:	683b      	ldr	r3, [r7, #0]
 8001040:	701a      	strb	r2, [r3, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8001042:	683b      	ldr	r3, [r7, #0]
 8001044:	785b      	ldrb	r3, [r3, #1]
 8001046:	4618      	mov	r0, r3
 8001048:	f000 fa58 	bl	80014fc <RTC_Bcd2ToByte>
 800104c:	4603      	mov	r3, r0
 800104e:	461a      	mov	r2, r3
 8001050:	683b      	ldr	r3, [r7, #0]
 8001052:	705a      	strb	r2, [r3, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 8001054:	683b      	ldr	r3, [r7, #0]
 8001056:	789b      	ldrb	r3, [r3, #2]
 8001058:	4618      	mov	r0, r3
 800105a:	f000 fa4f 	bl	80014fc <RTC_Bcd2ToByte>
 800105e:	4603      	mov	r3, r0
 8001060:	461a      	mov	r2, r3
 8001062:	683b      	ldr	r3, [r7, #0]
 8001064:	709a      	strb	r2, [r3, #2]
  }
}
 8001066:	bf00      	nop
 8001068:	3710      	adds	r7, #16
 800106a:	46bd      	mov	sp, r7
 800106c:	bd80      	pop	{r7, pc}
 800106e:	bf00      	nop
 8001070:	40002800 	.word	0x40002800

08001074 <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8001074:	b590      	push	{r4, r7, lr}
 8001076:	b085      	sub	sp, #20
 8001078:	af00      	add	r7, sp, #0
 800107a:	6078      	str	r0, [r7, #4]
 800107c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800107e:	2300      	movs	r3, #0
 8001080:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8001082:	2300      	movs	r3, #0
 8001084:	72fb      	strb	r3, [r7, #11]
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8001086:	687b      	ldr	r3, [r7, #4]
 8001088:	2b00      	cmp	r3, #0
 800108a:	d10e      	bne.n	80010aa <RTC_SetDate+0x36>
 800108c:	683b      	ldr	r3, [r7, #0]
 800108e:	785b      	ldrb	r3, [r3, #1]
 8001090:	f003 0310 	and.w	r3, r3, #16
 8001094:	2b00      	cmp	r3, #0
 8001096:	d008      	beq.n	80010aa <RTC_SetDate+0x36>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8001098:	683b      	ldr	r3, [r7, #0]
 800109a:	785b      	ldrb	r3, [r3, #1]
 800109c:	f023 0310 	bic.w	r3, r3, #16
 80010a0:	b2db      	uxtb	r3, r3
 80010a2:	330a      	adds	r3, #10
 80010a4:	b2da      	uxtb	r2, r3
 80010a6:	683b      	ldr	r3, [r7, #0]
 80010a8:	705a      	strb	r2, [r3, #1]
  }  
  if (RTC_Format == RTC_Format_BIN)
 80010aa:	687b      	ldr	r3, [r7, #4]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d00d      	beq.n	80010cc <RTC_SetDate+0x58>
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 80010b0:	683b      	ldr	r3, [r7, #0]
 80010b2:	785b      	ldrb	r3, [r3, #1]
 80010b4:	4618      	mov	r0, r3
 80010b6:	f000 fa21 	bl	80014fc <RTC_Bcd2ToByte>
 80010ba:	4603      	mov	r3, r0
 80010bc:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 80010be:	683b      	ldr	r3, [r7, #0]
 80010c0:	789b      	ldrb	r3, [r3, #2]
 80010c2:	4618      	mov	r0, r3
 80010c4:	f000 fa1a 	bl	80014fc <RTC_Bcd2ToByte>
 80010c8:	4603      	mov	r3, r0
 80010ca:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 80010cc:	687b      	ldr	r3, [r7, #4]
 80010ce:	2b00      	cmp	r3, #0
 80010d0:	d00f      	beq.n	80010f2 <RTC_SetDate+0x7e>
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 80010d2:	683b      	ldr	r3, [r7, #0]
 80010d4:	78db      	ldrb	r3, [r3, #3]
 80010d6:	041a      	lsls	r2, r3, #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 80010d8:	683b      	ldr	r3, [r7, #0]
 80010da:	785b      	ldrb	r3, [r3, #1]
 80010dc:	021b      	lsls	r3, r3, #8
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 80010de:	4313      	orrs	r3, r2
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 80010e0:	683a      	ldr	r2, [r7, #0]
 80010e2:	7892      	ldrb	r2, [r2, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 80010e4:	431a      	orrs	r2, r3
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 80010e6:	683b      	ldr	r3, [r7, #0]
 80010e8:	781b      	ldrb	r3, [r3, #0]
 80010ea:	035b      	lsls	r3, r3, #13
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 80010ec:	4313      	orrs	r3, r2
 80010ee:	60fb      	str	r3, [r7, #12]
 80010f0:	e01b      	b.n	800112a <RTC_SetDate+0xb6>
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 80010f2:	683b      	ldr	r3, [r7, #0]
 80010f4:	78db      	ldrb	r3, [r3, #3]
 80010f6:	4618      	mov	r0, r3
 80010f8:	f000 f9e2 	bl	80014c0 <RTC_ByteToBcd2>
 80010fc:	4603      	mov	r3, r0
 80010fe:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8001100:	683b      	ldr	r3, [r7, #0]
 8001102:	785b      	ldrb	r3, [r3, #1]
 8001104:	4618      	mov	r0, r3
 8001106:	f000 f9db 	bl	80014c0 <RTC_ByteToBcd2>
 800110a:	4603      	mov	r3, r0
 800110c:	021b      	lsls	r3, r3, #8
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 800110e:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8001110:	683b      	ldr	r3, [r7, #0]
 8001112:	789b      	ldrb	r3, [r3, #2]
 8001114:	4618      	mov	r0, r3
 8001116:	f000 f9d3 	bl	80014c0 <RTC_ByteToBcd2>
 800111a:	4603      	mov	r3, r0
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 800111c:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8001120:	683b      	ldr	r3, [r7, #0]
 8001122:	781b      	ldrb	r3, [r3, #0]
 8001124:	035b      	lsls	r3, r3, #13
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8001126:	4313      	orrs	r3, r2
 8001128:	60fb      	str	r3, [r7, #12]
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800112a:	4b19      	ldr	r3, [pc, #100]	; (8001190 <RTC_SetDate+0x11c>)
 800112c:	22ca      	movs	r2, #202	; 0xca
 800112e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8001130:	4b17      	ldr	r3, [pc, #92]	; (8001190 <RTC_SetDate+0x11c>)
 8001132:	2253      	movs	r2, #83	; 0x53
 8001134:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8001136:	f7ff fe25 	bl	8000d84 <RTC_EnterInitMode>
 800113a:	4603      	mov	r3, r0
 800113c:	2b00      	cmp	r3, #0
 800113e:	d102      	bne.n	8001146 <RTC_SetDate+0xd2>
  {
    status = ERROR;
 8001140:	2300      	movs	r3, #0
 8001142:	72fb      	strb	r3, [r7, #11]
 8001144:	e01b      	b.n	800117e <RTC_SetDate+0x10a>
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8001146:	4a12      	ldr	r2, [pc, #72]	; (8001190 <RTC_SetDate+0x11c>)
 8001148:	68fb      	ldr	r3, [r7, #12]
 800114a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800114e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8001152:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8001154:	f7ff fe50 	bl	8000df8 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8001158:	4b0d      	ldr	r3, [pc, #52]	; (8001190 <RTC_SetDate+0x11c>)
 800115a:	689b      	ldr	r3, [r3, #8]
 800115c:	f003 0320 	and.w	r3, r3, #32
 8001160:	2b00      	cmp	r3, #0
 8001162:	d10a      	bne.n	800117a <RTC_SetDate+0x106>
    {
    if(RTC_WaitForSynchro() == ERROR)
 8001164:	f7ff fe58 	bl	8000e18 <RTC_WaitForSynchro>
 8001168:	4603      	mov	r3, r0
 800116a:	2b00      	cmp	r3, #0
 800116c:	d102      	bne.n	8001174 <RTC_SetDate+0x100>
    {
      status = ERROR;
 800116e:	2300      	movs	r3, #0
 8001170:	72fb      	strb	r3, [r7, #11]
 8001172:	e004      	b.n	800117e <RTC_SetDate+0x10a>
    }
    else
    {
      status = SUCCESS;
 8001174:	2301      	movs	r3, #1
 8001176:	72fb      	strb	r3, [r7, #11]
 8001178:	e001      	b.n	800117e <RTC_SetDate+0x10a>
    }
  }
    else
    {
      status = SUCCESS;
 800117a:	2301      	movs	r3, #1
 800117c:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 800117e:	4b04      	ldr	r3, [pc, #16]	; (8001190 <RTC_SetDate+0x11c>)
 8001180:	22ff      	movs	r2, #255	; 0xff
 8001182:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8001184:	7afb      	ldrb	r3, [r7, #11]
}
 8001186:	4618      	mov	r0, r3
 8001188:	3714      	adds	r7, #20
 800118a:	46bd      	mov	sp, r7
 800118c:	bd90      	pop	{r4, r7, pc}
 800118e:	bf00      	nop
 8001190:	40002800 	.word	0x40002800

08001194 <RTC_DateStructInit>:
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
 8001194:	b480      	push	{r7}
 8001196:	b083      	sub	sp, #12
 8001198:	af00      	add	r7, sp, #0
 800119a:	6078      	str	r0, [r7, #4]
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 800119c:	687b      	ldr	r3, [r7, #4]
 800119e:	2201      	movs	r2, #1
 80011a0:	701a      	strb	r2, [r3, #0]
  RTC_DateStruct->RTC_Date = 1;
 80011a2:	687b      	ldr	r3, [r7, #4]
 80011a4:	2201      	movs	r2, #1
 80011a6:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 80011a8:	687b      	ldr	r3, [r7, #4]
 80011aa:	2201      	movs	r2, #1
 80011ac:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Year = 0;
 80011ae:	687b      	ldr	r3, [r7, #4]
 80011b0:	2200      	movs	r2, #0
 80011b2:	70da      	strb	r2, [r3, #3]
}
 80011b4:	bf00      	nop
 80011b6:	370c      	adds	r7, #12
 80011b8:	46bd      	mov	sp, r7
 80011ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011be:	4770      	bx	lr

080011c0 <RTC_SetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 80011c0:	b590      	push	{r4, r7, lr}
 80011c2:	b087      	sub	sp, #28
 80011c4:	af00      	add	r7, sp, #0
 80011c6:	60f8      	str	r0, [r7, #12]
 80011c8:	60b9      	str	r1, [r7, #8]
 80011ca:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 80011cc:	2300      	movs	r3, #0
 80011ce:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 80011d0:	68fb      	ldr	r3, [r7, #12]
 80011d2:	2b00      	cmp	r3, #0
 80011d4:	d109      	bne.n	80011ea <RTC_SetAlarm+0x2a>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80011d6:	4b47      	ldr	r3, [pc, #284]	; (80012f4 <RTC_SetAlarm+0x134>)
 80011d8:	689b      	ldr	r3, [r3, #8]
 80011da:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80011de:	2b00      	cmp	r3, #0
 80011e0:	d127      	bne.n	8001232 <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 80011e2:	687b      	ldr	r3, [r7, #4]
 80011e4:	2200      	movs	r2, #0
 80011e6:	70da      	strb	r2, [r3, #3]
 80011e8:	e023      	b.n	8001232 <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80011ea:	4b42      	ldr	r3, [pc, #264]	; (80012f4 <RTC_SetAlarm+0x134>)
 80011ec:	689b      	ldr	r3, [r3, #8]
 80011ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80011f2:	2b00      	cmp	r3, #0
 80011f4:	d007      	beq.n	8001206 <RTC_SetAlarm+0x46>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 80011f6:	687b      	ldr	r3, [r7, #4]
 80011f8:	781b      	ldrb	r3, [r3, #0]
 80011fa:	4618      	mov	r0, r3
 80011fc:	f000 f97e 	bl	80014fc <RTC_Bcd2ToByte>
 8001200:	4603      	mov	r3, r0
 8001202:	617b      	str	r3, [r7, #20]
 8001204:	e002      	b.n	800120c <RTC_SetAlarm+0x4c>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8001206:	687b      	ldr	r3, [r7, #4]
 8001208:	2200      	movs	r2, #0
 800120a:	70da      	strb	r2, [r3, #3]
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 800120c:	687b      	ldr	r3, [r7, #4]
 800120e:	689b      	ldr	r3, [r3, #8]
 8001210:	2b00      	cmp	r3, #0
 8001212:	d107      	bne.n	8001224 <RTC_SetAlarm+0x64>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8001214:	687b      	ldr	r3, [r7, #4]
 8001216:	7b1b      	ldrb	r3, [r3, #12]
 8001218:	4618      	mov	r0, r3
 800121a:	f000 f96f 	bl	80014fc <RTC_Bcd2ToByte>
 800121e:	4603      	mov	r3, r0
 8001220:	617b      	str	r3, [r7, #20]
 8001222:	e006      	b.n	8001232 <RTC_SetAlarm+0x72>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8001224:	687b      	ldr	r3, [r7, #4]
 8001226:	7b1b      	ldrb	r3, [r3, #12]
 8001228:	4618      	mov	r0, r3
 800122a:	f000 f967 	bl	80014fc <RTC_Bcd2ToByte>
 800122e:	4603      	mov	r3, r0
 8001230:	617b      	str	r3, [r7, #20]
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8001232:	68fb      	ldr	r3, [r7, #12]
 8001234:	2b00      	cmp	r3, #0
 8001236:	d019      	beq.n	800126c <RTC_SetAlarm+0xac>
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8001238:	687b      	ldr	r3, [r7, #4]
 800123a:	781b      	ldrb	r3, [r3, #0]
 800123c:	041a      	lsls	r2, r3, #16
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 800123e:	687b      	ldr	r3, [r7, #4]
 8001240:	785b      	ldrb	r3, [r3, #1]
 8001242:	021b      	lsls	r3, r3, #8
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8001244:	4313      	orrs	r3, r2
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8001246:	687a      	ldr	r2, [r7, #4]
 8001248:	7892      	ldrb	r2, [r2, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 800124a:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 800124c:	687b      	ldr	r3, [r7, #4]
 800124e:	78db      	ldrb	r3, [r3, #3]
 8001250:	041b      	lsls	r3, r3, #16
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8001252:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8001254:	687b      	ldr	r3, [r7, #4]
 8001256:	7b1b      	ldrb	r3, [r3, #12]
 8001258:	061b      	lsls	r3, r3, #24
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 800125a:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 800125c:	687b      	ldr	r3, [r7, #4]
 800125e:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8001260:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 8001262:	687b      	ldr	r3, [r7, #4]
 8001264:	685b      	ldr	r3, [r3, #4]
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8001266:	4313      	orrs	r3, r2
 8001268:	617b      	str	r3, [r7, #20]
 800126a:	e02b      	b.n	80012c4 <RTC_SetAlarm+0x104>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 800126c:	687b      	ldr	r3, [r7, #4]
 800126e:	781b      	ldrb	r3, [r3, #0]
 8001270:	4618      	mov	r0, r3
 8001272:	f000 f925 	bl	80014c0 <RTC_ByteToBcd2>
 8001276:	4603      	mov	r3, r0
 8001278:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 800127a:	687b      	ldr	r3, [r7, #4]
 800127c:	785b      	ldrb	r3, [r3, #1]
 800127e:	4618      	mov	r0, r3
 8001280:	f000 f91e 	bl	80014c0 <RTC_ByteToBcd2>
 8001284:	4603      	mov	r3, r0
 8001286:	021b      	lsls	r3, r3, #8
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8001288:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 800128a:	687b      	ldr	r3, [r7, #4]
 800128c:	789b      	ldrb	r3, [r3, #2]
 800128e:	4618      	mov	r0, r3
 8001290:	f000 f916 	bl	80014c0 <RTC_ByteToBcd2>
 8001294:	4603      	mov	r3, r0
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8001296:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 800129a:	687b      	ldr	r3, [r7, #4]
 800129c:	78db      	ldrb	r3, [r3, #3]
 800129e:	041b      	lsls	r3, r3, #16
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 80012a0:	ea42 0403 	orr.w	r4, r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80012a4:	687b      	ldr	r3, [r7, #4]
 80012a6:	7b1b      	ldrb	r3, [r3, #12]
 80012a8:	4618      	mov	r0, r3
 80012aa:	f000 f909 	bl	80014c0 <RTC_ByteToBcd2>
 80012ae:	4603      	mov	r3, r0
 80012b0:	061b      	lsls	r3, r3, #24
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 80012b2:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 80012b6:	687b      	ldr	r3, [r7, #4]
 80012b8:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80012ba:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 80012bc:	687b      	ldr	r3, [r7, #4]
 80012be:	685b      	ldr	r3, [r3, #4]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 80012c0:	4313      	orrs	r3, r2
 80012c2:	617b      	str	r3, [r7, #20]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80012c4:	4b0b      	ldr	r3, [pc, #44]	; (80012f4 <RTC_SetAlarm+0x134>)
 80012c6:	22ca      	movs	r2, #202	; 0xca
 80012c8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80012ca:	4b0a      	ldr	r3, [pc, #40]	; (80012f4 <RTC_SetAlarm+0x134>)
 80012cc:	2253      	movs	r2, #83	; 0x53
 80012ce:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 80012d0:	68bb      	ldr	r3, [r7, #8]
 80012d2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80012d6:	d103      	bne.n	80012e0 <RTC_SetAlarm+0x120>
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 80012d8:	4a06      	ldr	r2, [pc, #24]	; (80012f4 <RTC_SetAlarm+0x134>)
 80012da:	697b      	ldr	r3, [r7, #20]
 80012dc:	61d3      	str	r3, [r2, #28]
 80012de:	e002      	b.n	80012e6 <RTC_SetAlarm+0x126>
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 80012e0:	4a04      	ldr	r2, [pc, #16]	; (80012f4 <RTC_SetAlarm+0x134>)
 80012e2:	697b      	ldr	r3, [r7, #20]
 80012e4:	6213      	str	r3, [r2, #32]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 80012e6:	4b03      	ldr	r3, [pc, #12]	; (80012f4 <RTC_SetAlarm+0x134>)
 80012e8:	22ff      	movs	r2, #255	; 0xff
 80012ea:	625a      	str	r2, [r3, #36]	; 0x24
}
 80012ec:	bf00      	nop
 80012ee:	371c      	adds	r7, #28
 80012f0:	46bd      	mov	sp, r7
 80012f2:	bd90      	pop	{r4, r7, pc}
 80012f4:	40002800 	.word	0x40002800

080012f8 <RTC_AlarmCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 80012f8:	b480      	push	{r7}
 80012fa:	b087      	sub	sp, #28
 80012fc:	af00      	add	r7, sp, #0
 80012fe:	6078      	str	r0, [r7, #4]
 8001300:	460b      	mov	r3, r1
 8001302:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t alarmcounter = 0x00;
 8001304:	2300      	movs	r3, #0
 8001306:	60fb      	str	r3, [r7, #12]
  uint32_t alarmstatus = 0x00;
 8001308:	2300      	movs	r3, #0
 800130a:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 800130c:	2300      	movs	r3, #0
 800130e:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8001310:	4b1f      	ldr	r3, [pc, #124]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001312:	22ca      	movs	r2, #202	; 0xca
 8001314:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8001316:	4b1e      	ldr	r3, [pc, #120]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001318:	2253      	movs	r2, #83	; 0x53
 800131a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 800131c:	78fb      	ldrb	r3, [r7, #3]
 800131e:	2b00      	cmp	r3, #0
 8001320:	d008      	beq.n	8001334 <RTC_AlarmCmd+0x3c>
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8001322:	491b      	ldr	r1, [pc, #108]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001324:	4b1a      	ldr	r3, [pc, #104]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001326:	689a      	ldr	r2, [r3, #8]
 8001328:	687b      	ldr	r3, [r7, #4]
 800132a:	4313      	orrs	r3, r2
 800132c:	608b      	str	r3, [r1, #8]

    status = SUCCESS;    
 800132e:	2301      	movs	r3, #1
 8001330:	75fb      	strb	r3, [r7, #23]
 8001332:	e022      	b.n	800137a <RTC_AlarmCmd+0x82>
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 8001334:	4916      	ldr	r1, [pc, #88]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001336:	4b16      	ldr	r3, [pc, #88]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001338:	689a      	ldr	r2, [r3, #8]
 800133a:	687b      	ldr	r3, [r7, #4]
 800133c:	43db      	mvns	r3, r3
 800133e:	4013      	ands	r3, r2
 8001340:	608b      	str	r3, [r1, #8]
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8001342:	4b13      	ldr	r3, [pc, #76]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001344:	68da      	ldr	r2, [r3, #12]
 8001346:	687b      	ldr	r3, [r7, #4]
 8001348:	0a1b      	lsrs	r3, r3, #8
 800134a:	4013      	ands	r3, r2
 800134c:	613b      	str	r3, [r7, #16]
      alarmcounter++;  
 800134e:	68fb      	ldr	r3, [r7, #12]
 8001350:	3301      	adds	r3, #1
 8001352:	60fb      	str	r3, [r7, #12]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8001354:	68fb      	ldr	r3, [r7, #12]
 8001356:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800135a:	d002      	beq.n	8001362 <RTC_AlarmCmd+0x6a>
 800135c:	693b      	ldr	r3, [r7, #16]
 800135e:	2b00      	cmp	r3, #0
 8001360:	d0ef      	beq.n	8001342 <RTC_AlarmCmd+0x4a>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 8001362:	4b0b      	ldr	r3, [pc, #44]	; (8001390 <RTC_AlarmCmd+0x98>)
 8001364:	68da      	ldr	r2, [r3, #12]
 8001366:	687b      	ldr	r3, [r7, #4]
 8001368:	0a1b      	lsrs	r3, r3, #8
 800136a:	4013      	ands	r3, r2
 800136c:	2b00      	cmp	r3, #0
 800136e:	d102      	bne.n	8001376 <RTC_AlarmCmd+0x7e>
    {
      status = ERROR;
 8001370:	2300      	movs	r3, #0
 8001372:	75fb      	strb	r3, [r7, #23]
 8001374:	e001      	b.n	800137a <RTC_AlarmCmd+0x82>
    } 
    else
    {
      status = SUCCESS;
 8001376:	2301      	movs	r3, #1
 8001378:	75fb      	strb	r3, [r7, #23]
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800137a:	4b05      	ldr	r3, [pc, #20]	; (8001390 <RTC_AlarmCmd+0x98>)
 800137c:	22ff      	movs	r2, #255	; 0xff
 800137e:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8001380:	7dfb      	ldrb	r3, [r7, #23]
}
 8001382:	4618      	mov	r0, r3
 8001384:	371c      	adds	r7, #28
 8001386:	46bd      	mov	sp, r7
 8001388:	f85d 7b04 	ldr.w	r7, [sp], #4
 800138c:	4770      	bx	lr
 800138e:	bf00      	nop
 8001390:	40002800 	.word	0x40002800

08001394 <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
 8001394:	b480      	push	{r7}
 8001396:	b083      	sub	sp, #12
 8001398:	af00      	add	r7, sp, #0
 800139a:	6078      	str	r0, [r7, #4]
 800139c:	460b      	mov	r3, r1
 800139e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80013a0:	4b1a      	ldr	r3, [pc, #104]	; (800140c <RTC_ITConfig+0x78>)
 80013a2:	22ca      	movs	r2, #202	; 0xca
 80013a4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80013a6:	4b19      	ldr	r3, [pc, #100]	; (800140c <RTC_ITConfig+0x78>)
 80013a8:	2253      	movs	r2, #83	; 0x53
 80013aa:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 80013ac:	78fb      	ldrb	r3, [r7, #3]
 80013ae:	2b00      	cmp	r3, #0
 80013b0:	d010      	beq.n	80013d4 <RTC_ITConfig+0x40>
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 80013b2:	4916      	ldr	r1, [pc, #88]	; (800140c <RTC_ITConfig+0x78>)
 80013b4:	4b15      	ldr	r3, [pc, #84]	; (800140c <RTC_ITConfig+0x78>)
 80013b6:	689a      	ldr	r2, [r3, #8]
 80013b8:	687b      	ldr	r3, [r7, #4]
 80013ba:	f023 0304 	bic.w	r3, r3, #4
 80013be:	4313      	orrs	r3, r2
 80013c0:	608b      	str	r3, [r1, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 80013c2:	4912      	ldr	r1, [pc, #72]	; (800140c <RTC_ITConfig+0x78>)
 80013c4:	4b11      	ldr	r3, [pc, #68]	; (800140c <RTC_ITConfig+0x78>)
 80013c6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013c8:	687b      	ldr	r3, [r7, #4]
 80013ca:	f003 0304 	and.w	r3, r3, #4
 80013ce:	4313      	orrs	r3, r2
 80013d0:	640b      	str	r3, [r1, #64]	; 0x40
 80013d2:	e011      	b.n	80013f8 <RTC_ITConfig+0x64>
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 80013d4:	490d      	ldr	r1, [pc, #52]	; (800140c <RTC_ITConfig+0x78>)
 80013d6:	4b0d      	ldr	r3, [pc, #52]	; (800140c <RTC_ITConfig+0x78>)
 80013d8:	689a      	ldr	r2, [r3, #8]
 80013da:	687b      	ldr	r3, [r7, #4]
 80013dc:	f023 0304 	bic.w	r3, r3, #4
 80013e0:	43db      	mvns	r3, r3
 80013e2:	4013      	ands	r3, r2
 80013e4:	608b      	str	r3, [r1, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 80013e6:	4909      	ldr	r1, [pc, #36]	; (800140c <RTC_ITConfig+0x78>)
 80013e8:	4b08      	ldr	r3, [pc, #32]	; (800140c <RTC_ITConfig+0x78>)
 80013ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013ec:	687b      	ldr	r3, [r7, #4]
 80013ee:	f003 0304 	and.w	r3, r3, #4
 80013f2:	43db      	mvns	r3, r3
 80013f4:	4013      	ands	r3, r2
 80013f6:	640b      	str	r3, [r1, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80013f8:	4b04      	ldr	r3, [pc, #16]	; (800140c <RTC_ITConfig+0x78>)
 80013fa:	22ff      	movs	r2, #255	; 0xff
 80013fc:	625a      	str	r2, [r3, #36]	; 0x24
}
 80013fe:	bf00      	nop
 8001400:	370c      	adds	r7, #12
 8001402:	46bd      	mov	sp, r7
 8001404:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001408:	4770      	bx	lr
 800140a:	bf00      	nop
 800140c:	40002800 	.word	0x40002800

08001410 <RTC_GetFlagStatus>:
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
 8001410:	b480      	push	{r7}
 8001412:	b085      	sub	sp, #20
 8001414:	af00      	add	r7, sp, #0
 8001416:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8001418:	2300      	movs	r3, #0
 800141a:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 800141c:	2300      	movs	r3, #0
 800141e:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 8001420:	4b0a      	ldr	r3, [pc, #40]	; (800144c <RTC_GetFlagStatus+0x3c>)
 8001422:	68da      	ldr	r2, [r3, #12]
 8001424:	4b0a      	ldr	r3, [pc, #40]	; (8001450 <RTC_GetFlagStatus+0x40>)
 8001426:	4013      	ands	r3, r2
 8001428:	60bb      	str	r3, [r7, #8]
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 800142a:	68ba      	ldr	r2, [r7, #8]
 800142c:	687b      	ldr	r3, [r7, #4]
 800142e:	4013      	ands	r3, r2
 8001430:	2b00      	cmp	r3, #0
 8001432:	d002      	beq.n	800143a <RTC_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 8001434:	2301      	movs	r3, #1
 8001436:	73fb      	strb	r3, [r7, #15]
 8001438:	e001      	b.n	800143e <RTC_GetFlagStatus+0x2e>
  }
  else
  {
    bitstatus = RESET;
 800143a:	2300      	movs	r3, #0
 800143c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800143e:	7bfb      	ldrb	r3, [r7, #15]
}
 8001440:	4618      	mov	r0, r3
 8001442:	3714      	adds	r7, #20
 8001444:	46bd      	mov	sp, r7
 8001446:	f85d 7b04 	ldr.w	r7, [sp], #4
 800144a:	4770      	bx	lr
 800144c:	40002800 	.word	0x40002800
 8001450:	00013f7f 	.word	0x00013f7f

08001454 <RTC_ClearFlag>:
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
 8001454:	b480      	push	{r7}
 8001456:	b083      	sub	sp, #12
 8001458:	af00      	add	r7, sp, #0
 800145a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 800145c:	4908      	ldr	r1, [pc, #32]	; (8001480 <RTC_ClearFlag+0x2c>)
 800145e:	687b      	ldr	r3, [r7, #4]
 8001460:	b29b      	uxth	r3, r3
 8001462:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001466:	43da      	mvns	r2, r3
 8001468:	4b05      	ldr	r3, [pc, #20]	; (8001480 <RTC_ClearFlag+0x2c>)
 800146a:	68db      	ldr	r3, [r3, #12]
 800146c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001470:	4313      	orrs	r3, r2
 8001472:	60cb      	str	r3, [r1, #12]
}
 8001474:	bf00      	nop
 8001476:	370c      	adds	r7, #12
 8001478:	46bd      	mov	sp, r7
 800147a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800147e:	4770      	bx	lr
 8001480:	40002800 	.word	0x40002800

08001484 <RTC_ClearITPendingBit>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
 8001484:	b480      	push	{r7}
 8001486:	b085      	sub	sp, #20
 8001488:	af00      	add	r7, sp, #0
 800148a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800148c:	2300      	movs	r3, #0
 800148e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);
 8001490:	687b      	ldr	r3, [r7, #4]
 8001492:	091b      	lsrs	r3, r3, #4
 8001494:	60fb      	str	r3, [r7, #12]

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 8001496:	4909      	ldr	r1, [pc, #36]	; (80014bc <RTC_ClearITPendingBit+0x38>)
 8001498:	68fb      	ldr	r3, [r7, #12]
 800149a:	b29b      	uxth	r3, r3
 800149c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80014a0:	43da      	mvns	r2, r3
 80014a2:	4b06      	ldr	r3, [pc, #24]	; (80014bc <RTC_ClearITPendingBit+0x38>)
 80014a4:	68db      	ldr	r3, [r3, #12]
 80014a6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80014aa:	4313      	orrs	r3, r2
 80014ac:	60cb      	str	r3, [r1, #12]
}
 80014ae:	bf00      	nop
 80014b0:	3714      	adds	r7, #20
 80014b2:	46bd      	mov	sp, r7
 80014b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014b8:	4770      	bx	lr
 80014ba:	bf00      	nop
 80014bc:	40002800 	.word	0x40002800

080014c0 <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 80014c0:	b480      	push	{r7}
 80014c2:	b085      	sub	sp, #20
 80014c4:	af00      	add	r7, sp, #0
 80014c6:	4603      	mov	r3, r0
 80014c8:	71fb      	strb	r3, [r7, #7]
  uint8_t bcdhigh = 0;
 80014ca:	2300      	movs	r3, #0
 80014cc:	73fb      	strb	r3, [r7, #15]
  
  while (Value >= 10)
 80014ce:	e005      	b.n	80014dc <RTC_ByteToBcd2+0x1c>
  {
    bcdhigh++;
 80014d0:	7bfb      	ldrb	r3, [r7, #15]
 80014d2:	3301      	adds	r3, #1
 80014d4:	73fb      	strb	r3, [r7, #15]
    Value -= 10;
 80014d6:	79fb      	ldrb	r3, [r7, #7]
 80014d8:	3b0a      	subs	r3, #10
 80014da:	71fb      	strb	r3, [r7, #7]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80014dc:	79fb      	ldrb	r3, [r7, #7]
 80014de:	2b09      	cmp	r3, #9
 80014e0:	d8f6      	bhi.n	80014d0 <RTC_ByteToBcd2+0x10>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 80014e2:	7bfb      	ldrb	r3, [r7, #15]
 80014e4:	011b      	lsls	r3, r3, #4
 80014e6:	b2da      	uxtb	r2, r3
 80014e8:	79fb      	ldrb	r3, [r7, #7]
 80014ea:	4313      	orrs	r3, r2
 80014ec:	b2db      	uxtb	r3, r3
}
 80014ee:	4618      	mov	r0, r3
 80014f0:	3714      	adds	r7, #20
 80014f2:	46bd      	mov	sp, r7
 80014f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014f8:	4770      	bx	lr
 80014fa:	bf00      	nop

080014fc <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 80014fc:	b480      	push	{r7}
 80014fe:	b085      	sub	sp, #20
 8001500:	af00      	add	r7, sp, #0
 8001502:	4603      	mov	r3, r0
 8001504:	71fb      	strb	r3, [r7, #7]
  uint8_t tmp = 0;
 8001506:	2300      	movs	r3, #0
 8001508:	73fb      	strb	r3, [r7, #15]
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 800150a:	79fb      	ldrb	r3, [r7, #7]
 800150c:	091b      	lsrs	r3, r3, #4
 800150e:	b2db      	uxtb	r3, r3
 8001510:	461a      	mov	r2, r3
 8001512:	0092      	lsls	r2, r2, #2
 8001514:	4413      	add	r3, r2
 8001516:	005b      	lsls	r3, r3, #1
 8001518:	73fb      	strb	r3, [r7, #15]
  return (tmp + (Value & (uint8_t)0x0F));
 800151a:	79fb      	ldrb	r3, [r7, #7]
 800151c:	f003 030f 	and.w	r3, r3, #15
 8001520:	b2da      	uxtb	r2, r3
 8001522:	7bfb      	ldrb	r3, [r7, #15]
 8001524:	4413      	add	r3, r2
 8001526:	b2db      	uxtb	r3, r3
}
 8001528:	4618      	mov	r0, r3
 800152a:	3714      	adds	r7, #20
 800152c:	46bd      	mov	sp, r7
 800152e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001532:	4770      	bx	lr

08001534 <STM_EVAL_LEDInit>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 8001534:	b580      	push	{r7, lr}
 8001536:	b084      	sub	sp, #16
 8001538:	af00      	add	r7, sp, #0
 800153a:	4603      	mov	r3, r0
 800153c:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800153e:	79fb      	ldrb	r3, [r7, #7]
 8001540:	4a10      	ldr	r2, [pc, #64]	; (8001584 <STM_EVAL_LEDInit+0x50>)
 8001542:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001546:	2101      	movs	r1, #1
 8001548:	4618      	mov	r0, r3
 800154a:	f7ff fb0b 	bl	8000b64 <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800154e:	79fb      	ldrb	r3, [r7, #7]
 8001550:	4a0d      	ldr	r2, [pc, #52]	; (8001588 <STM_EVAL_LEDInit+0x54>)
 8001552:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001556:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8001558:	2301      	movs	r3, #1
 800155a:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800155c:	2300      	movs	r3, #0
 800155e:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8001560:	2301      	movs	r3, #1
 8001562:	73fb      	strb	r3, [r7, #15]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001564:	2302      	movs	r3, #2
 8001566:	737b      	strb	r3, [r7, #13]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 8001568:	79fb      	ldrb	r3, [r7, #7]
 800156a:	4a08      	ldr	r2, [pc, #32]	; (800158c <STM_EVAL_LEDInit+0x58>)
 800156c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001570:	f107 0208 	add.w	r2, r7, #8
 8001574:	4611      	mov	r1, r2
 8001576:	4618      	mov	r0, r3
 8001578:	f7ff f824 	bl	80005c4 <GPIO_Init>
}
 800157c:	bf00      	nop
 800157e:	3710      	adds	r7, #16
 8001580:	46bd      	mov	sp, r7
 8001582:	bd80      	pop	{r7, pc}
 8001584:	0800236c 	.word	0x0800236c
 8001588:	08002364 	.word	0x08002364
 800158c:	20000010 	.word	0x20000010

08001590 <STM_EVAL_LEDOn>:
  *     @arg LED5
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
 8001590:	b480      	push	{r7}
 8001592:	b083      	sub	sp, #12
 8001594:	af00      	add	r7, sp, #0
 8001596:	4603      	mov	r3, r0
 8001598:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 800159a:	79fb      	ldrb	r3, [r7, #7]
 800159c:	4a06      	ldr	r2, [pc, #24]	; (80015b8 <STM_EVAL_LEDOn+0x28>)
 800159e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80015a2:	79fa      	ldrb	r2, [r7, #7]
 80015a4:	4905      	ldr	r1, [pc, #20]	; (80015bc <STM_EVAL_LEDOn+0x2c>)
 80015a6:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 80015aa:	831a      	strh	r2, [r3, #24]
}
 80015ac:	bf00      	nop
 80015ae:	370c      	adds	r7, #12
 80015b0:	46bd      	mov	sp, r7
 80015b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015b6:	4770      	bx	lr
 80015b8:	20000010 	.word	0x20000010
 80015bc:	08002364 	.word	0x08002364

080015c0 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80015c0:	b480      	push	{r7}
 80015c2:	b083      	sub	sp, #12
 80015c4:	af00      	add	r7, sp, #0
 80015c6:	4603      	mov	r3, r0
 80015c8:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 80015ca:	4909      	ldr	r1, [pc, #36]	; (80015f0 <NVIC_EnableIRQ+0x30>)
 80015cc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80015d0:	095b      	lsrs	r3, r3, #5
 80015d2:	79fa      	ldrb	r2, [r7, #7]
 80015d4:	f002 021f 	and.w	r2, r2, #31
 80015d8:	2001      	movs	r0, #1
 80015da:	fa00 f202 	lsl.w	r2, r0, r2
 80015de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80015e2:	bf00      	nop
 80015e4:	370c      	adds	r7, #12
 80015e6:	46bd      	mov	sp, r7
 80015e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015ec:	4770      	bx	lr
 80015ee:	bf00      	nop
 80015f0:	e000e100 	.word	0xe000e100

080015f4 <init_RTC>:


void init_Delay(void);

void init_RTC()
{
 80015f4:	b580      	push	{r7, lr}
 80015f6:	b086      	sub	sp, #24
 80015f8:	af00      	add	r7, sp, #0
	/*Disable register write protect */
//	RTC_WriteProtectionCmd(DISABLE);
	/* Enter Initialisation mode */
//	RTC_EnterInitMode();
//	while(RTC_GetFlagStatus(RTC_FLAG_INITF) != SET);
	init_RTC_LSI();
 80015fa:	f000 f823 	bl	8001644 <init_RTC_LSI>
	/* Program prescalers (NOTE: Dependent on input clock source)*/
	RTC_InitTypeDef RTC_InitStruct;
	RTC_InitStruct.RTC_HourFormat = RTC_HourFormat_24;
 80015fe:	2300      	movs	r3, #0
 8001600:	60fb      	str	r3, [r7, #12]
	RTC_InitStruct.RTC_AsynchPrediv = 127; //values from AN3371
 8001602:	237f      	movs	r3, #127	; 0x7f
 8001604:	613b      	str	r3, [r7, #16]
	RTC_InitStruct.RTC_SynchPrediv = 249;
 8001606:	23f9      	movs	r3, #249	; 0xf9
 8001608:	617b      	str	r3, [r7, #20]
	RTC_Init(&RTC_InitStruct);
 800160a:	f107 030c 	add.w	r3, r7, #12
 800160e:	4618      	mov	r0, r3
 8001610:	f7ff fb62 	bl	8000cd8 <RTC_Init>

	/* init Time and Date to default values*/
	RTC_DateTypeDef RTC_DateStruct;
	RTC_TimeTypeDef RTC_TimeStruct;
	RTC_DateStructInit(&RTC_DateStruct);
 8001614:	f107 0308 	add.w	r3, r7, #8
 8001618:	4618      	mov	r0, r3
 800161a:	f7ff fdbb 	bl	8001194 <RTC_DateStructInit>
	RTC_TimeStructInit(&RTC_TimeStruct);
 800161e:	1d3b      	adds	r3, r7, #4
 8001620:	4618      	mov	r0, r3
 8001622:	f7ff fcbf 	bl	8000fa4 <RTC_TimeStructInit>
	RTC_SetTime(RTC_Format_BIN,&RTC_TimeStruct);
 8001626:	1d3b      	adds	r3, r7, #4
 8001628:	4619      	mov	r1, r3
 800162a:	2000      	movs	r0, #0
 800162c:	f7ff fc30 	bl	8000e90 <RTC_SetTime>
	RTC_SetDate(RTC_Format_BIN,&RTC_DateStruct);
 8001630:	f107 0308 	add.w	r3, r7, #8
 8001634:	4619      	mov	r1, r3
 8001636:	2000      	movs	r0, #0
 8001638:	f7ff fd1c 	bl	8001074 <RTC_SetDate>

}
 800163c:	bf00      	nop
 800163e:	3718      	adds	r7, #24
 8001640:	46bd      	mov	sp, r7
 8001642:	bd80      	pop	{r7, pc}

08001644 <init_RTC_LSI>:
/*
 * Configure RTC to use LSE clock
 */
void init_RTC_LSI(void)
{
 8001644:	b580      	push	{r7, lr}
 8001646:	af00      	add	r7, sp, #0
	/* Allow access to the RTC */
	PWR_BackupAccessCmd(ENABLE);
 8001648:	2001      	movs	r0, #1
 800164a:	f7ff f849 	bl	80006e0 <PWR_BackupAccessCmd>
	RCC_LSICmd(ENABLE);
 800164e:	2001      	movs	r0, #1
 8001650:	f7ff f8ee 	bl	8000830 <RCC_LSICmd>
	while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET);
 8001654:	bf00      	nop
 8001656:	2061      	movs	r0, #97	; 0x61
 8001658:	f7ff fb04 	bl	8000c64 <RCC_GetFlagStatus>
 800165c:	4603      	mov	r3, r0
 800165e:	2b00      	cmp	r3, #0
 8001660:	d0f9      	beq.n	8001656 <init_RTC_LSI+0x12>

	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
 8001662:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001666:	f7ff fa3f 	bl	8000ae8 <RCC_RTCCLKConfig>
	RCC_RTCCLKCmd(ENABLE);
 800166a:	2001      	movs	r0, #1
 800166c:	f7ff fa6a 	bl	8000b44 <RCC_RTCCLKCmd>
	RTC_WaitForSynchro();
 8001670:	f7ff fbd2 	bl	8000e18 <RTC_WaitForSynchro>
}
 8001674:	bf00      	nop
 8001676:	bd80      	pop	{r7, pc}

08001678 <set_RTCAlarm_A>:
void set_RTCAlarm_A(RTC_TimeTypeDef* RTC_Alarmtime,RTC_AlarmTypeDef* Alarm_val)
{
 8001678:	b580      	push	{r7, lr}
 800167a:	b08a      	sub	sp, #40	; 0x28
 800167c:	af00      	add	r7, sp, #0
 800167e:	6078      	str	r0, [r7, #4]
 8001680:	6039      	str	r1, [r7, #0]


	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8001682:	2101      	movs	r1, #1
 8001684:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001688:	f7ff faac 	bl	8000be4 <RCC_APB2PeriphClockCmd>
	/* Configure Alarm*/
	// disable write protection
	RTC_WriteProtectionCmd(DISABLE);
 800168c:	2000      	movs	r0, #0
 800168e:	f7ff fb5f 	bl	8000d50 <RTC_WriteProtectionCmd>
	/* Disable Alarm*/
	/* Clear any pending bits*/
	RTC_ClearFlag(RTC_FLAG_ALRAF);
 8001692:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001696:	f7ff fedd 	bl	8001454 <RTC_ClearFlag>
	RTC_AlarmCmd(RTC_Alarm_A,DISABLE);
 800169a:	2100      	movs	r1, #0
 800169c:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016a0:	f7ff fe2a 	bl	80012f8 <RTC_AlarmCmd>
	while(RTC_GetFlagStatus(RTC_FLAG_ALRAWF) == RESET);
 80016a4:	bf00      	nop
 80016a6:	2001      	movs	r0, #1
 80016a8:	f7ff feb2 	bl	8001410 <RTC_GetFlagStatus>
 80016ac:	4603      	mov	r3, r0
 80016ae:	2b00      	cmp	r3, #0
 80016b0:	d0f9      	beq.n	80016a6 <set_RTCAlarm_A+0x2e>

	RTC_AlarmTypeDef RTC_AlarmInitStruct;
	RTC_AlarmInitStruct.RTC_AlarmTime.RTC_Hours = RTC_Alarmtime->RTC_Hours;
 80016b2:	687b      	ldr	r3, [r7, #4]
 80016b4:	781b      	ldrb	r3, [r3, #0]
 80016b6:	763b      	strb	r3, [r7, #24]
	RTC_AlarmInitStruct.RTC_AlarmTime.RTC_Minutes = RTC_Alarmtime->RTC_Minutes ;
 80016b8:	687b      	ldr	r3, [r7, #4]
 80016ba:	785b      	ldrb	r3, [r3, #1]
 80016bc:	767b      	strb	r3, [r7, #25]
	RTC_AlarmInitStruct.RTC_AlarmTime.RTC_Seconds = RTC_Alarmtime->RTC_Seconds;
 80016be:	687b      	ldr	r3, [r7, #4]
 80016c0:	789b      	ldrb	r3, [r3, #2]
 80016c2:	76bb      	strb	r3, [r7, #26]
	RTC_AlarmInitStruct.RTC_AlarmDateWeekDaySel =  Alarm_val->RTC_AlarmDateWeekDaySel;
 80016c4:	683b      	ldr	r3, [r7, #0]
 80016c6:	689b      	ldr	r3, [r3, #8]
 80016c8:	623b      	str	r3, [r7, #32]
	RTC_AlarmInitStruct.RTC_AlarmDateWeekDay = Alarm_val->RTC_AlarmDateWeekDay;
 80016ca:	683b      	ldr	r3, [r7, #0]
 80016cc:	7b1b      	ldrb	r3, [r3, #12]
 80016ce:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	RTC_AlarmInitStruct.RTC_AlarmMask = Alarm_val->RTC_AlarmMask;
 80016d2:	683b      	ldr	r3, [r7, #0]
 80016d4:	685b      	ldr	r3, [r3, #4]
 80016d6:	61fb      	str	r3, [r7, #28]

	/*set alarm interrupt*/
	RTC_SetAlarm(RTC_Format_BIN,RTC_Alarm_A,&RTC_AlarmInitStruct);
 80016d8:	f107 0318 	add.w	r3, r7, #24
 80016dc:	461a      	mov	r2, r3
 80016de:	f44f 7180 	mov.w	r1, #256	; 0x100
 80016e2:	2000      	movs	r0, #0
 80016e4:	f7ff fd6c 	bl	80011c0 <RTC_SetAlarm>

	RTC_AlarmCmd(RTC_Alarm_A,ENABLE);
 80016e8:	2101      	movs	r1, #1
 80016ea:	f44f 7080 	mov.w	r0, #256	; 0x100
 80016ee:	f7ff fe03 	bl	80012f8 <RTC_AlarmCmd>
	RTC_WriteProtectionCmd(ENABLE);
 80016f2:	2001      	movs	r0, #1
 80016f4:	f7ff fb2c 	bl	8000d50 <RTC_WriteProtectionCmd>

	RTC_ITConfig(RTC_IT_ALRA,ENABLE);
 80016f8:	2101      	movs	r1, #1
 80016fa:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80016fe:	f7ff fe49 	bl	8001394 <RTC_ITConfig>
	/* Map alarm to EXTI 17*/
	EXTI_InitTypeDef EXTI_InitStruct;
	EXTI_InitStruct.EXTI_Line = EXTI_Line17;
 8001702:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001706:	613b      	str	r3, [r7, #16]
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
 8001708:	2300      	movs	r3, #0
 800170a:	753b      	strb	r3, [r7, #20]
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;
 800170c:	2308      	movs	r3, #8
 800170e:	757b      	strb	r3, [r7, #21]
	EXTI_InitStruct.EXTI_LineCmd = ENABLE;
 8001710:	2301      	movs	r3, #1
 8001712:	75bb      	strb	r3, [r7, #22]
	EXTI_Init(&EXTI_InitStruct);
 8001714:	f107 0310 	add.w	r3, r7, #16
 8001718:	4618      	mov	r0, r3
 800171a:	f7fe fdb7 	bl	800028c <EXTI_Init>

	/* Enable interrupt in NVIC */
	NVIC_InitTypeDef NVIC_InitStruct;
	NVIC_InitStruct.NVIC_IRQChannel = RTC_Alarm_IRQn;
 800171e:	2329      	movs	r3, #41	; 0x29
 8001720:	733b      	strb	r3, [r7, #12]
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;
 8001722:	2301      	movs	r3, #1
 8001724:	737b      	strb	r3, [r7, #13]
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;
 8001726:	2301      	movs	r3, #1
 8001728:	73bb      	strb	r3, [r7, #14]
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
 800172a:	2301      	movs	r3, #1
 800172c:	73fb      	strb	r3, [r7, #15]
	NVIC_Init(&NVIC_InitStruct);
 800172e:	f107 030c 	add.w	r3, r7, #12
 8001732:	4618      	mov	r0, r3
 8001734:	f7fe fd48 	bl	80001c8 <NVIC_Init>
	NVIC_EnableIRQ(RTC_Alarm_IRQn);
 8001738:	2029      	movs	r0, #41	; 0x29
 800173a:	f7ff ff41 	bl	80015c0 <NVIC_EnableIRQ>

	//clear any pending interrupt flags
	RTC_ClearITPendingBit(RTC_IT_ALRA);
 800173e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001742:	f7ff fe9f 	bl	8001484 <RTC_ClearITPendingBit>
	RTC_ClearFlag(RTC_FLAG_ALRAF);
 8001746:	f44f 7080 	mov.w	r0, #256	; 0x100
 800174a:	f7ff fe83 	bl	8001454 <RTC_ClearFlag>



}
 800174e:	bf00      	nop
 8001750:	3728      	adds	r7, #40	; 0x28
 8001752:	46bd      	mov	sp, r7
 8001754:	bd80      	pop	{r7, pc}
 8001756:	bf00      	nop

08001758 <set_StdBy_Mode>:
	RTC_WriteProtectionCmd(ENABLE);


}
void set_StdBy_Mode(void)
{
 8001758:	b580      	push	{r7, lr}
 800175a:	af00      	add	r7, sp, #0
	/* Enable Power command*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);
 800175c:	2101      	movs	r1, #1
 800175e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8001762:	f7ff fa1f 	bl	8000ba4 <RCC_APB1PeriphClockCmd>
	/* Set sleep deep bit*/
	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8001766:	4a0d      	ldr	r2, [pc, #52]	; (800179c <set_StdBy_Mode+0x44>)
 8001768:	4b0c      	ldr	r3, [pc, #48]	; (800179c <set_StdBy_Mode+0x44>)
 800176a:	691b      	ldr	r3, [r3, #16]
 800176c:	f043 0304 	orr.w	r3, r3, #4
 8001770:	6113      	str	r3, [r2, #16]
	/* select stdby mode*/
	PWR->CR |= PWR_CR_PDDS;
 8001772:	4a0b      	ldr	r2, [pc, #44]	; (80017a0 <set_StdBy_Mode+0x48>)
 8001774:	4b0a      	ldr	r3, [pc, #40]	; (80017a0 <set_StdBy_Mode+0x48>)
 8001776:	681b      	ldr	r3, [r3, #0]
 8001778:	f043 0302 	orr.w	r3, r3, #2
 800177c:	6013      	str	r3, [r2, #0]
	/* Clear Wake Up flag*/
	PWR->CR |= PWR_CR_CWUF;
 800177e:	4a08      	ldr	r2, [pc, #32]	; (80017a0 <set_StdBy_Mode+0x48>)
 8001780:	4b07      	ldr	r3, [pc, #28]	; (80017a0 <set_StdBy_Mode+0x48>)
 8001782:	681b      	ldr	r3, [r3, #0]
 8001784:	f043 0304 	orr.w	r3, r3, #4
 8001788:	6013      	str	r3, [r2, #0]
	/* enable wake up pin*/
	PWR->CSR |= PWR_CSR_EWUP;
 800178a:	4a05      	ldr	r2, [pc, #20]	; (80017a0 <set_StdBy_Mode+0x48>)
 800178c:	4b04      	ldr	r3, [pc, #16]	; (80017a0 <set_StdBy_Mode+0x48>)
 800178e:	685b      	ldr	r3, [r3, #4]
 8001790:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001794:	6053      	str	r3, [r2, #4]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8001796:	bf30      	wfi
	//clear pending interrupts
	/* request wait for interrupt*/
	__WFI();

}
 8001798:	bf00      	nop
 800179a:	bd80      	pop	{r7, pc}
 800179c:	e000ed00 	.word	0xe000ed00
 80017a0:	40007000 	.word	0x40007000

080017a4 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
 80017a4:	b480      	push	{r7}
 80017a6:	af00      	add	r7, sp, #0

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80017a8:	bf00      	nop
	__NOP();
}
 80017aa:	bf00      	nop
 80017ac:	46bd      	mov	sp, r7
 80017ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017b2:	4770      	bx	lr

080017b4 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler()
{
 80017b4:	b580      	push	{r7, lr}
 80017b6:	af00      	add	r7, sp, #0

	RTC_ClearITPendingBit(RTC_IT_ALRA);
 80017b8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80017bc:	f7ff fe62 	bl	8001484 <RTC_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line17);
 80017c0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80017c4:	f7fe fdd4 	bl	8000370 <EXTI_ClearITPendingBit>
}
 80017c8:	bf00      	nop
 80017ca:	bd80      	pop	{r7, pc}

080017cc <RTC_WKUP_IRQHandler>:


void RTC_WKUP_IRQHandler()
{
 80017cc:	b480      	push	{r7}
 80017ce:	af00      	add	r7, sp, #0
 80017d0:	bf00      	nop
	__NOP();
}
 80017d2:	bf00      	nop
 80017d4:	46bd      	mov	sp, r7
 80017d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017da:	4770      	bx	lr

080017dc <EE_Init>:
  * @param  None.
  * @retval - Flash error code: on write Flash error
  *         - FLASH_COMPLETE: on success
  */
uint16_t EE_Init(void)
{
 80017dc:	b580      	push	{r7, lr}
 80017de:	b084      	sub	sp, #16
 80017e0:	af00      	add	r7, sp, #0
  uint16_t PageStatus0 = 6, PageStatus1 = 6;
 80017e2:	2306      	movs	r3, #6
 80017e4:	817b      	strh	r3, [r7, #10]
 80017e6:	2306      	movs	r3, #6
 80017e8:	813b      	strh	r3, [r7, #8]
  uint16_t VarIdx = 0;
 80017ea:	2300      	movs	r3, #0
 80017ec:	81fb      	strh	r3, [r7, #14]
  uint16_t EepromStatus = 0, ReadStatus = 0;
 80017ee:	2300      	movs	r3, #0
 80017f0:	80fb      	strh	r3, [r7, #6]
 80017f2:	2300      	movs	r3, #0
 80017f4:	80bb      	strh	r3, [r7, #4]
  int16_t x = -1;
 80017f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80017fa:	81bb      	strh	r3, [r7, #12]
  uint16_t  FlashStatus;

  /* Get Page0 status */
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80017fc:	4b9d      	ldr	r3, [pc, #628]	; (8001a74 <EE_Init+0x298>)
 80017fe:	881b      	ldrh	r3, [r3, #0]
 8001800:	817b      	strh	r3, [r7, #10]
  /* Get Page1 status */
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8001802:	4b9d      	ldr	r3, [pc, #628]	; (8001a78 <EE_Init+0x29c>)
 8001804:	881b      	ldrh	r3, [r3, #0]
 8001806:	813b      	strh	r3, [r7, #8]

  /* Check for invalid header states and repair if necessary */
  switch (PageStatus0)
 8001808:	897b      	ldrh	r3, [r7, #10]
 800180a:	f64e 62ee 	movw	r2, #61166	; 0xeeee
 800180e:	4293      	cmp	r3, r2
 8001810:	d03c      	beq.n	800188c <EE_Init+0xb0>
 8001812:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001816:	4293      	cmp	r3, r2
 8001818:	d003      	beq.n	8001822 <EE_Init+0x46>
 800181a:	2b00      	cmp	r3, #0
 800181c:	f000 80ab 	beq.w	8001976 <EE_Init+0x19a>
 8001820:	e112      	b.n	8001a48 <EE_Init+0x26c>
  {
    case ERASED:
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 8001822:	893b      	ldrh	r3, [r7, #8]
 8001824:	2b00      	cmp	r3, #0
 8001826:	d10b      	bne.n	8001840 <EE_Init+0x64>
      {
        /* Erase Page0 */
        FlashStatus = FLASH_EraseSector(PAGE0_ID,VOLTAGE_RANGE);
 8001828:	2102      	movs	r1, #2
 800182a:	2010      	movs	r0, #16
 800182c:	f7fe fde8 	bl	8000400 <FLASH_EraseSector>
 8001830:	4603      	mov	r3, r0
 8001832:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001834:	887b      	ldrh	r3, [r7, #2]
 8001836:	2b08      	cmp	r3, #8
 8001838:	f000 810f 	beq.w	8001a5a <EE_Init+0x27e>
        {
          return FlashStatus;
 800183c:	887b      	ldrh	r3, [r7, #2]
 800183e:	e114      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 8001840:	893b      	ldrh	r3, [r7, #8]
 8001842:	f64e 62ee 	movw	r2, #61166	; 0xeeee
 8001846:	4293      	cmp	r3, r2
 8001848:	d116      	bne.n	8001878 <EE_Init+0x9c>
      {
        /* Erase Page0 */
        FlashStatus = FLASH_EraseSector(PAGE0_ID, VOLTAGE_RANGE);
 800184a:	2102      	movs	r1, #2
 800184c:	2010      	movs	r0, #16
 800184e:	f7fe fdd7 	bl	8000400 <FLASH_EraseSector>
 8001852:	4603      	mov	r3, r0
 8001854:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001856:	887b      	ldrh	r3, [r7, #2]
 8001858:	2b08      	cmp	r3, #8
 800185a:	d001      	beq.n	8001860 <EE_Init+0x84>
        {
          return FlashStatus;
 800185c:	887b      	ldrh	r3, [r7, #2]
 800185e:	e104      	b.n	8001a6a <EE_Init+0x28e>
        }
        /* Mark Page1 as valid */
        FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 8001860:	2100      	movs	r1, #0
 8001862:	4885      	ldr	r0, [pc, #532]	; (8001a78 <EE_Init+0x29c>)
 8001864:	f7fe fe2c 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001868:	4603      	mov	r3, r0
 800186a:	807b      	strh	r3, [r7, #2]
        /* If program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 800186c:	887b      	ldrh	r3, [r7, #2]
 800186e:	2b08      	cmp	r3, #8
 8001870:	f000 80f3 	beq.w	8001a5a <EE_Init+0x27e>
        {
          return FlashStatus;
 8001874:	887b      	ldrh	r3, [r7, #2]
 8001876:	e0f8      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else /* First EEPROM access (Page0&1 are erased) or invalid state -> format EEPROM */
      {
        /* Erase both Page0 and Page1 and set Page0 as valid page */
        FlashStatus = EE_Format();
 8001878:	f000 f97c 	bl	8001b74 <EE_Format>
 800187c:	4603      	mov	r3, r0
 800187e:	807b      	strh	r3, [r7, #2]
        /* If erase/program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001880:	887b      	ldrh	r3, [r7, #2]
 8001882:	2b08      	cmp	r3, #8
 8001884:	f000 80e9 	beq.w	8001a5a <EE_Init+0x27e>
        {
          return FlashStatus;
 8001888:	887b      	ldrh	r3, [r7, #2]
 800188a:	e0ee      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      break;

    case RECEIVE_DATA:
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 800188c:	893b      	ldrh	r3, [r7, #8]
 800188e:	2b00      	cmp	r3, #0
 8001890:	d14d      	bne.n	800192e <EE_Init+0x152>
      {
        /* Transfer data from Page1 to Page0 */
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8001892:	2300      	movs	r3, #0
 8001894:	81fb      	strh	r3, [r7, #14]
 8001896:	e030      	b.n	80018fa <EE_Init+0x11e>
        {
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8001898:	4b78      	ldr	r3, [pc, #480]	; (8001a7c <EE_Init+0x2a0>)
 800189a:	881b      	ldrh	r3, [r3, #0]
 800189c:	b29a      	uxth	r2, r3
 800189e:	89fb      	ldrh	r3, [r7, #14]
 80018a0:	4977      	ldr	r1, [pc, #476]	; (8001a80 <EE_Init+0x2a4>)
 80018a2:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 80018a6:	429a      	cmp	r2, r3
 80018a8:	d101      	bne.n	80018ae <EE_Init+0xd2>
          {
            x = VarIdx;
 80018aa:	89fb      	ldrh	r3, [r7, #14]
 80018ac:	81bb      	strh	r3, [r7, #12]
          }
          if (VarIdx != x)
 80018ae:	89fa      	ldrh	r2, [r7, #14]
 80018b0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80018b4:	429a      	cmp	r2, r3
 80018b6:	d01d      	beq.n	80018f4 <EE_Init+0x118>
          {
            /* Read the last variables' updates */
            ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 80018b8:	89fb      	ldrh	r3, [r7, #14]
 80018ba:	4a71      	ldr	r2, [pc, #452]	; (8001a80 <EE_Init+0x2a4>)
 80018bc:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80018c0:	4970      	ldr	r1, [pc, #448]	; (8001a84 <EE_Init+0x2a8>)
 80018c2:	4618      	mov	r0, r3
 80018c4:	f000 f8e2 	bl	8001a8c <EE_ReadVariable>
 80018c8:	4603      	mov	r3, r0
 80018ca:	80bb      	strh	r3, [r7, #4]
            /* In case variable corresponding to the virtual address was found */
            if (ReadStatus != 0x1)
 80018cc:	88bb      	ldrh	r3, [r7, #4]
 80018ce:	2b01      	cmp	r3, #1
 80018d0:	d010      	beq.n	80018f4 <EE_Init+0x118>
            {
              /* Transfer the variable to the Page0 */
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 80018d2:	89fb      	ldrh	r3, [r7, #14]
 80018d4:	4a6a      	ldr	r2, [pc, #424]	; (8001a80 <EE_Init+0x2a4>)
 80018d6:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 80018da:	4b6a      	ldr	r3, [pc, #424]	; (8001a84 <EE_Init+0x2a8>)
 80018dc:	881b      	ldrh	r3, [r3, #0]
 80018de:	4619      	mov	r1, r3
 80018e0:	4610      	mov	r0, r2
 80018e2:	f000 f9b5 	bl	8001c50 <EE_VerifyPageFullWriteVariable>
 80018e6:	4603      	mov	r3, r0
 80018e8:	80fb      	strh	r3, [r7, #6]
              /* If program operation was failed, a Flash error code is returned */
              if (EepromStatus != FLASH_COMPLETE)
 80018ea:	88fb      	ldrh	r3, [r7, #6]
 80018ec:	2b08      	cmp	r3, #8
 80018ee:	d001      	beq.n	80018f4 <EE_Init+0x118>
              {
                return EepromStatus;
 80018f0:	88fb      	ldrh	r3, [r7, #6]
 80018f2:	e0ba      	b.n	8001a6a <EE_Init+0x28e>

    case RECEIVE_DATA:
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
      {
        /* Transfer data from Page1 to Page0 */
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80018f4:	89fb      	ldrh	r3, [r7, #14]
 80018f6:	3301      	adds	r3, #1
 80018f8:	81fb      	strh	r3, [r7, #14]
 80018fa:	89fb      	ldrh	r3, [r7, #14]
 80018fc:	2b02      	cmp	r3, #2
 80018fe:	d9cb      	bls.n	8001898 <EE_Init+0xbc>
              }
            }
          }
        }
        /* Mark Page0 as valid */
        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8001900:	2100      	movs	r1, #0
 8001902:	485c      	ldr	r0, [pc, #368]	; (8001a74 <EE_Init+0x298>)
 8001904:	f7fe fddc 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001908:	4603      	mov	r3, r0
 800190a:	807b      	strh	r3, [r7, #2]
        /* If program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 800190c:	887b      	ldrh	r3, [r7, #2]
 800190e:	2b08      	cmp	r3, #8
 8001910:	d001      	beq.n	8001916 <EE_Init+0x13a>
        {
          return FlashStatus;
 8001912:	887b      	ldrh	r3, [r7, #2]
 8001914:	e0a9      	b.n	8001a6a <EE_Init+0x28e>
        }
        /* Erase Page1 */
        FlashStatus = FLASH_EraseSector(PAGE1_ID, VOLTAGE_RANGE);
 8001916:	2102      	movs	r1, #2
 8001918:	2018      	movs	r0, #24
 800191a:	f7fe fd71 	bl	8000400 <FLASH_EraseSector>
 800191e:	4603      	mov	r3, r0
 8001920:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001922:	887b      	ldrh	r3, [r7, #2]
 8001924:	2b08      	cmp	r3, #8
 8001926:	f000 809a 	beq.w	8001a5e <EE_Init+0x282>
        {
          return FlashStatus;
 800192a:	887b      	ldrh	r3, [r7, #2]
 800192c:	e09d      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 800192e:	893b      	ldrh	r3, [r7, #8]
 8001930:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001934:	4293      	cmp	r3, r2
 8001936:	d115      	bne.n	8001964 <EE_Init+0x188>
      {
        /* Erase Page1 */
        FlashStatus = FLASH_EraseSector(PAGE1_ID, VOLTAGE_RANGE);
 8001938:	2102      	movs	r1, #2
 800193a:	2018      	movs	r0, #24
 800193c:	f7fe fd60 	bl	8000400 <FLASH_EraseSector>
 8001940:	4603      	mov	r3, r0
 8001942:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001944:	887b      	ldrh	r3, [r7, #2]
 8001946:	2b08      	cmp	r3, #8
 8001948:	d001      	beq.n	800194e <EE_Init+0x172>
        {
          return FlashStatus;
 800194a:	887b      	ldrh	r3, [r7, #2]
 800194c:	e08d      	b.n	8001a6a <EE_Init+0x28e>
        }
        /* Mark Page0 as valid */
        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 800194e:	2100      	movs	r1, #0
 8001950:	4848      	ldr	r0, [pc, #288]	; (8001a74 <EE_Init+0x298>)
 8001952:	f7fe fdb5 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001956:	4603      	mov	r3, r0
 8001958:	807b      	strh	r3, [r7, #2]
        /* If program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 800195a:	887b      	ldrh	r3, [r7, #2]
 800195c:	2b08      	cmp	r3, #8
 800195e:	d07e      	beq.n	8001a5e <EE_Init+0x282>
        {
          return FlashStatus;
 8001960:	887b      	ldrh	r3, [r7, #2]
 8001962:	e082      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else /* Invalid state -> format eeprom */
      {
        /* Erase both Page0 and Page1 and set Page0 as valid page */
        FlashStatus = EE_Format();
 8001964:	f000 f906 	bl	8001b74 <EE_Format>
 8001968:	4603      	mov	r3, r0
 800196a:	807b      	strh	r3, [r7, #2]
        /* If erase/program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 800196c:	887b      	ldrh	r3, [r7, #2]
 800196e:	2b08      	cmp	r3, #8
 8001970:	d075      	beq.n	8001a5e <EE_Init+0x282>
        {
          return FlashStatus;
 8001972:	887b      	ldrh	r3, [r7, #2]
 8001974:	e079      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      break;

    case VALID_PAGE:
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 8001976:	893b      	ldrh	r3, [r7, #8]
 8001978:	2b00      	cmp	r3, #0
 800197a:	d108      	bne.n	800198e <EE_Init+0x1b2>
      {
        /* Erase both Page0 and Page1 and set Page0 as valid page */
        FlashStatus = EE_Format();
 800197c:	f000 f8fa 	bl	8001b74 <EE_Format>
 8001980:	4603      	mov	r3, r0
 8001982:	807b      	strh	r3, [r7, #2]
        /* If erase/program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001984:	887b      	ldrh	r3, [r7, #2]
 8001986:	2b08      	cmp	r3, #8
 8001988:	d06b      	beq.n	8001a62 <EE_Init+0x286>
        {
          return FlashStatus;
 800198a:	887b      	ldrh	r3, [r7, #2]
 800198c:	e06d      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 800198e:	893b      	ldrh	r3, [r7, #8]
 8001990:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001994:	4293      	cmp	r3, r2
 8001996:	d10a      	bne.n	80019ae <EE_Init+0x1d2>
      {
        /* Erase Page1 */
        FlashStatus = FLASH_EraseSector(PAGE1_ID, VOLTAGE_RANGE);
 8001998:	2102      	movs	r1, #2
 800199a:	2018      	movs	r0, #24
 800199c:	f7fe fd30 	bl	8000400 <FLASH_EraseSector>
 80019a0:	4603      	mov	r3, r0
 80019a2:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 80019a4:	887b      	ldrh	r3, [r7, #2]
 80019a6:	2b08      	cmp	r3, #8
 80019a8:	d05b      	beq.n	8001a62 <EE_Init+0x286>
        {
          return FlashStatus;
 80019aa:	887b      	ldrh	r3, [r7, #2]
 80019ac:	e05d      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else /* Page0 valid, Page1 receive */
      {
        /* Transfer data from Page0 to Page1 */
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80019ae:	2300      	movs	r3, #0
 80019b0:	81fb      	strh	r3, [r7, #14]
 80019b2:	e030      	b.n	8001a16 <EE_Init+0x23a>
        {
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 80019b4:	4b34      	ldr	r3, [pc, #208]	; (8001a88 <EE_Init+0x2ac>)
 80019b6:	881b      	ldrh	r3, [r3, #0]
 80019b8:	b29a      	uxth	r2, r3
 80019ba:	89fb      	ldrh	r3, [r7, #14]
 80019bc:	4930      	ldr	r1, [pc, #192]	; (8001a80 <EE_Init+0x2a4>)
 80019be:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 80019c2:	429a      	cmp	r2, r3
 80019c4:	d101      	bne.n	80019ca <EE_Init+0x1ee>
          {
            x = VarIdx;
 80019c6:	89fb      	ldrh	r3, [r7, #14]
 80019c8:	81bb      	strh	r3, [r7, #12]
          }
          if (VarIdx != x)
 80019ca:	89fa      	ldrh	r2, [r7, #14]
 80019cc:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80019d0:	429a      	cmp	r2, r3
 80019d2:	d01d      	beq.n	8001a10 <EE_Init+0x234>
          {
            /* Read the last variables' updates */
            ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 80019d4:	89fb      	ldrh	r3, [r7, #14]
 80019d6:	4a2a      	ldr	r2, [pc, #168]	; (8001a80 <EE_Init+0x2a4>)
 80019d8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80019dc:	4929      	ldr	r1, [pc, #164]	; (8001a84 <EE_Init+0x2a8>)
 80019de:	4618      	mov	r0, r3
 80019e0:	f000 f854 	bl	8001a8c <EE_ReadVariable>
 80019e4:	4603      	mov	r3, r0
 80019e6:	80bb      	strh	r3, [r7, #4]
            /* In case variable corresponding to the virtual address was found */
            if (ReadStatus != 0x1)
 80019e8:	88bb      	ldrh	r3, [r7, #4]
 80019ea:	2b01      	cmp	r3, #1
 80019ec:	d010      	beq.n	8001a10 <EE_Init+0x234>
            {
              /* Transfer the variable to the Page1 */
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 80019ee:	89fb      	ldrh	r3, [r7, #14]
 80019f0:	4a23      	ldr	r2, [pc, #140]	; (8001a80 <EE_Init+0x2a4>)
 80019f2:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 80019f6:	4b23      	ldr	r3, [pc, #140]	; (8001a84 <EE_Init+0x2a8>)
 80019f8:	881b      	ldrh	r3, [r3, #0]
 80019fa:	4619      	mov	r1, r3
 80019fc:	4610      	mov	r0, r2
 80019fe:	f000 f927 	bl	8001c50 <EE_VerifyPageFullWriteVariable>
 8001a02:	4603      	mov	r3, r0
 8001a04:	80fb      	strh	r3, [r7, #6]
              /* If program operation was failed, a Flash error code is returned */
              if (EepromStatus != FLASH_COMPLETE)
 8001a06:	88fb      	ldrh	r3, [r7, #6]
 8001a08:	2b08      	cmp	r3, #8
 8001a0a:	d001      	beq.n	8001a10 <EE_Init+0x234>
              {
                return EepromStatus;
 8001a0c:	88fb      	ldrh	r3, [r7, #6]
 8001a0e:	e02c      	b.n	8001a6a <EE_Init+0x28e>
        }
      }
      else /* Page0 valid, Page1 receive */
      {
        /* Transfer data from Page0 to Page1 */
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8001a10:	89fb      	ldrh	r3, [r7, #14]
 8001a12:	3301      	adds	r3, #1
 8001a14:	81fb      	strh	r3, [r7, #14]
 8001a16:	89fb      	ldrh	r3, [r7, #14]
 8001a18:	2b02      	cmp	r3, #2
 8001a1a:	d9cb      	bls.n	80019b4 <EE_Init+0x1d8>
              }
            }
          }
        }
        /* Mark Page1 as valid */
        FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 8001a1c:	2100      	movs	r1, #0
 8001a1e:	4816      	ldr	r0, [pc, #88]	; (8001a78 <EE_Init+0x29c>)
 8001a20:	f7fe fd4e 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001a24:	4603      	mov	r3, r0
 8001a26:	807b      	strh	r3, [r7, #2]
        /* If program operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001a28:	887b      	ldrh	r3, [r7, #2]
 8001a2a:	2b08      	cmp	r3, #8
 8001a2c:	d001      	beq.n	8001a32 <EE_Init+0x256>
        {
          return FlashStatus;
 8001a2e:	887b      	ldrh	r3, [r7, #2]
 8001a30:	e01b      	b.n	8001a6a <EE_Init+0x28e>
        }
        /* Erase Page0 */
        FlashStatus = FLASH_EraseSector(PAGE0_ID, VOLTAGE_RANGE);
 8001a32:	2102      	movs	r1, #2
 8001a34:	2010      	movs	r0, #16
 8001a36:	f7fe fce3 	bl	8000400 <FLASH_EraseSector>
 8001a3a:	4603      	mov	r3, r0
 8001a3c:	807b      	strh	r3, [r7, #2]
        /* If erase operation was failed, a Flash error code is returned */
        if (FlashStatus != FLASH_COMPLETE)
 8001a3e:	887b      	ldrh	r3, [r7, #2]
 8001a40:	2b08      	cmp	r3, #8
 8001a42:	d00e      	beq.n	8001a62 <EE_Init+0x286>
        {
          return FlashStatus;
 8001a44:	887b      	ldrh	r3, [r7, #2]
 8001a46:	e010      	b.n	8001a6a <EE_Init+0x28e>
      }
      break;

    default:  /* Any other state -> format eeprom */
      /* Erase both Page0 and Page1 and set Page0 as valid page */
      FlashStatus = EE_Format();
 8001a48:	f000 f894 	bl	8001b74 <EE_Format>
 8001a4c:	4603      	mov	r3, r0
 8001a4e:	807b      	strh	r3, [r7, #2]
      /* If erase/program operation was failed, a Flash error code is returned */
      if (FlashStatus != FLASH_COMPLETE)
 8001a50:	887b      	ldrh	r3, [r7, #2]
 8001a52:	2b08      	cmp	r3, #8
 8001a54:	d007      	beq.n	8001a66 <EE_Init+0x28a>
      {
        return FlashStatus;
 8001a56:	887b      	ldrh	r3, [r7, #2]
 8001a58:	e007      	b.n	8001a6a <EE_Init+0x28e>
        if (FlashStatus != FLASH_COMPLETE)
        {
          return FlashStatus;
        }
      }
      break;
 8001a5a:	bf00      	nop
 8001a5c:	e004      	b.n	8001a68 <EE_Init+0x28c>
        if (FlashStatus != FLASH_COMPLETE)
        {
          return FlashStatus;
        }
      }
      break;
 8001a5e:	bf00      	nop
 8001a60:	e002      	b.n	8001a68 <EE_Init+0x28c>
        if (FlashStatus != FLASH_COMPLETE)
        {
          return FlashStatus;
        }
      }
      break;
 8001a62:	bf00      	nop
 8001a64:	e000      	b.n	8001a68 <EE_Init+0x28c>
      /* If erase/program operation was failed, a Flash error code is returned */
      if (FlashStatus != FLASH_COMPLETE)
      {
        return FlashStatus;
      }
      break;
 8001a66:	bf00      	nop
  }

  return FLASH_COMPLETE;
 8001a68:	2308      	movs	r3, #8
}
 8001a6a:	4618      	mov	r0, r3
 8001a6c:	3710      	adds	r7, #16
 8001a6e:	46bd      	mov	sp, r7
 8001a70:	bd80      	pop	{r7, pc}
 8001a72:	bf00      	nop
 8001a74:	08020000 	.word	0x08020000
 8001a78:	0803f400 	.word	0x0803f400
 8001a7c:	08020006 	.word	0x08020006
 8001a80:	20000020 	.word	0x20000020
 8001a84:	20000058 	.word	0x20000058
 8001a88:	0803f406 	.word	0x0803f406

08001a8c <EE_ReadVariable>:
  *           - 0: if variable was found
  *           - 1: if the variable was not found
  *           - NO_VALID_PAGE: if no valid page was found.
  */
uint16_t EE_ReadVariable(uint16_t VirtAddress, uint16_t* Data)
{
 8001a8c:	b580      	push	{r7, lr}
 8001a8e:	b086      	sub	sp, #24
 8001a90:	af00      	add	r7, sp, #0
 8001a92:	4603      	mov	r3, r0
 8001a94:	6039      	str	r1, [r7, #0]
 8001a96:	80fb      	strh	r3, [r7, #6]
  uint16_t ValidPage = PAGE0;
 8001a98:	2300      	movs	r3, #0
 8001a9a:	81fb      	strh	r3, [r7, #14]
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
 8001a9c:	f245 5355 	movw	r3, #21845	; 0x5555
 8001aa0:	81bb      	strh	r3, [r7, #12]
 8001aa2:	2301      	movs	r3, #1
 8001aa4:	82fb      	strh	r3, [r7, #22]
  uint32_t Address = EEPROM_START_ADDRESS, PageStartAddress = EEPROM_START_ADDRESS;
 8001aa6:	4b20      	ldr	r3, [pc, #128]	; (8001b28 <EE_ReadVariable+0x9c>)
 8001aa8:	613b      	str	r3, [r7, #16]
 8001aaa:	4b1f      	ldr	r3, [pc, #124]	; (8001b28 <EE_ReadVariable+0x9c>)
 8001aac:	60bb      	str	r3, [r7, #8]

  /* Get active Page for read operation */
  ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
 8001aae:	2000      	movs	r0, #0
 8001ab0:	f000 f888 	bl	8001bc4 <EE_FindValidPage>
 8001ab4:	4603      	mov	r3, r0
 8001ab6:	81fb      	strh	r3, [r7, #14]

  /* Check if there is no valid page */
  if (ValidPage == NO_VALID_PAGE)
 8001ab8:	89fb      	ldrh	r3, [r7, #14]
 8001aba:	2bab      	cmp	r3, #171	; 0xab
 8001abc:	d101      	bne.n	8001ac2 <EE_ReadVariable+0x36>
  {
    return  NO_VALID_PAGE;
 8001abe:	23ab      	movs	r3, #171	; 0xab
 8001ac0:	e02d      	b.n	8001b1e <EE_ReadVariable+0x92>
  }

  /* Get the valid Page start Address */
  PageStartAddress = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8001ac2:	89fb      	ldrh	r3, [r7, #14]
 8001ac4:	f44f 32fa 	mov.w	r2, #128000	; 0x1f400
 8001ac8:	fb02 f303 	mul.w	r3, r2, r3
 8001acc:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8001ad0:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8001ad4:	60bb      	str	r3, [r7, #8]

  /* Get the valid Page end Address */
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 8001ad6:	89fb      	ldrh	r3, [r7, #14]
 8001ad8:	3301      	adds	r3, #1
 8001ada:	461a      	mov	r2, r3
 8001adc:	f44f 33fa 	mov.w	r3, #128000	; 0x1f400
 8001ae0:	fb03 f202 	mul.w	r2, r3, r2
 8001ae4:	4b11      	ldr	r3, [pc, #68]	; (8001b2c <EE_ReadVariable+0xa0>)
 8001ae6:	4413      	add	r3, r2
 8001ae8:	613b      	str	r3, [r7, #16]

  /* Check each active page address starting from end */
  while (Address > (PageStartAddress + 2))
 8001aea:	e012      	b.n	8001b12 <EE_ReadVariable+0x86>
  {
    /* Get the current location content to be compared with virtual address */
    AddressValue = (*(__IO uint16_t*)Address);
 8001aec:	693b      	ldr	r3, [r7, #16]
 8001aee:	881b      	ldrh	r3, [r3, #0]
 8001af0:	81bb      	strh	r3, [r7, #12]

    /* Compare the read address with the virtual address */
    if (AddressValue == VirtAddress)
 8001af2:	89ba      	ldrh	r2, [r7, #12]
 8001af4:	88fb      	ldrh	r3, [r7, #6]
 8001af6:	429a      	cmp	r2, r3
 8001af8:	d108      	bne.n	8001b0c <EE_ReadVariable+0x80>
    {
      /* Get content of Address-2 which is variable value */
      *Data = (*(__IO uint16_t*)(Address - 2));
 8001afa:	693b      	ldr	r3, [r7, #16]
 8001afc:	3b02      	subs	r3, #2
 8001afe:	881b      	ldrh	r3, [r3, #0]
 8001b00:	b29a      	uxth	r2, r3
 8001b02:	683b      	ldr	r3, [r7, #0]
 8001b04:	801a      	strh	r2, [r3, #0]

      /* In case variable value is read, reset ReadStatus flag */
      ReadStatus = 0;
 8001b06:	2300      	movs	r3, #0
 8001b08:	82fb      	strh	r3, [r7, #22]

      break;
 8001b0a:	e007      	b.n	8001b1c <EE_ReadVariable+0x90>
    }
    else
    {
      /* Next address location */
      Address = Address - 4;
 8001b0c:	693b      	ldr	r3, [r7, #16]
 8001b0e:	3b04      	subs	r3, #4
 8001b10:	613b      	str	r3, [r7, #16]

  /* Get the valid Page end Address */
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));

  /* Check each active page address starting from end */
  while (Address > (PageStartAddress + 2))
 8001b12:	68bb      	ldr	r3, [r7, #8]
 8001b14:	1c9a      	adds	r2, r3, #2
 8001b16:	693b      	ldr	r3, [r7, #16]
 8001b18:	429a      	cmp	r2, r3
 8001b1a:	d3e7      	bcc.n	8001aec <EE_ReadVariable+0x60>
      /* Next address location */
      Address = Address - 4;
    }
  }
  /* Return ReadStatus value: (0: variable exist, 1: variable doesn't exist) */
  return ReadStatus;
 8001b1c:	8afb      	ldrh	r3, [r7, #22]
}
 8001b1e:	4618      	mov	r0, r3
 8001b20:	3718      	adds	r7, #24
 8001b22:	46bd      	mov	sp, r7
 8001b24:	bd80      	pop	{r7, pc}
 8001b26:	bf00      	nop
 8001b28:	08020000 	.word	0x08020000
 8001b2c:	0801fffe 	.word	0x0801fffe

08001b30 <EE_WriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
uint16_t EE_WriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 8001b30:	b580      	push	{r7, lr}
 8001b32:	b084      	sub	sp, #16
 8001b34:	af00      	add	r7, sp, #0
 8001b36:	4603      	mov	r3, r0
 8001b38:	460a      	mov	r2, r1
 8001b3a:	80fb      	strh	r3, [r7, #6]
 8001b3c:	4613      	mov	r3, r2
 8001b3e:	80bb      	strh	r3, [r7, #4]
  uint16_t Status = 0;
 8001b40:	2300      	movs	r3, #0
 8001b42:	81fb      	strh	r3, [r7, #14]

  /* Write the variable virtual address and value in the EEPROM */
  Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8001b44:	88ba      	ldrh	r2, [r7, #4]
 8001b46:	88fb      	ldrh	r3, [r7, #6]
 8001b48:	4611      	mov	r1, r2
 8001b4a:	4618      	mov	r0, r3
 8001b4c:	f000 f880 	bl	8001c50 <EE_VerifyPageFullWriteVariable>
 8001b50:	4603      	mov	r3, r0
 8001b52:	81fb      	strh	r3, [r7, #14]

  /* In case the EEPROM active page is full */
  if (Status == PAGE_FULL)
 8001b54:	89fb      	ldrh	r3, [r7, #14]
 8001b56:	2b80      	cmp	r3, #128	; 0x80
 8001b58:	d107      	bne.n	8001b6a <EE_WriteVariable+0x3a>
  {
    /* Perform Page transfer */
    Status = EE_PageTransfer(VirtAddress, Data);
 8001b5a:	88ba      	ldrh	r2, [r7, #4]
 8001b5c:	88fb      	ldrh	r3, [r7, #6]
 8001b5e:	4611      	mov	r1, r2
 8001b60:	4618      	mov	r0, r3
 8001b62:	f000 f8d5 	bl	8001d10 <EE_PageTransfer>
 8001b66:	4603      	mov	r3, r0
 8001b68:	81fb      	strh	r3, [r7, #14]
  }

  /* Return last operation status */
  return Status;
 8001b6a:	89fb      	ldrh	r3, [r7, #14]
}
 8001b6c:	4618      	mov	r0, r3
 8001b6e:	3710      	adds	r7, #16
 8001b70:	46bd      	mov	sp, r7
 8001b72:	bd80      	pop	{r7, pc}

08001b74 <EE_Format>:
  * @param  None
  * @retval Status of the last operation (Flash write or erase) done during
  *         EEPROM formating
  */
static FLASH_Status EE_Format(void)
{
 8001b74:	b580      	push	{r7, lr}
 8001b76:	b082      	sub	sp, #8
 8001b78:	af00      	add	r7, sp, #0
  FLASH_Status FlashStatus = FLASH_COMPLETE;
 8001b7a:	2308      	movs	r3, #8
 8001b7c:	71fb      	strb	r3, [r7, #7]

  /* Erase Page0 */
  FlashStatus = FLASH_EraseSector(PAGE0_ID, VOLTAGE_RANGE);
 8001b7e:	2102      	movs	r1, #2
 8001b80:	2010      	movs	r0, #16
 8001b82:	f7fe fc3d 	bl	8000400 <FLASH_EraseSector>
 8001b86:	4603      	mov	r3, r0
 8001b88:	71fb      	strb	r3, [r7, #7]

  /* If erase operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8001b8a:	79fb      	ldrb	r3, [r7, #7]
 8001b8c:	2b08      	cmp	r3, #8
 8001b8e:	d001      	beq.n	8001b94 <EE_Format+0x20>
  {
    return FlashStatus;
 8001b90:	79fb      	ldrb	r3, [r7, #7]
 8001b92:	e011      	b.n	8001bb8 <EE_Format+0x44>
  }

  /* Set Page0 as valid page: Write VALID_PAGE at Page0 base address */
  FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8001b94:	2100      	movs	r1, #0
 8001b96:	480a      	ldr	r0, [pc, #40]	; (8001bc0 <EE_Format+0x4c>)
 8001b98:	f7fe fc92 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001b9c:	4603      	mov	r3, r0
 8001b9e:	71fb      	strb	r3, [r7, #7]

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8001ba0:	79fb      	ldrb	r3, [r7, #7]
 8001ba2:	2b08      	cmp	r3, #8
 8001ba4:	d001      	beq.n	8001baa <EE_Format+0x36>
  {
    return FlashStatus;
 8001ba6:	79fb      	ldrb	r3, [r7, #7]
 8001ba8:	e006      	b.n	8001bb8 <EE_Format+0x44>
  }

  /* Erase Page1 */
  FlashStatus = FLASH_EraseSector(PAGE1_ID, VOLTAGE_RANGE);
 8001baa:	2102      	movs	r1, #2
 8001bac:	2018      	movs	r0, #24
 8001bae:	f7fe fc27 	bl	8000400 <FLASH_EraseSector>
 8001bb2:	4603      	mov	r3, r0
 8001bb4:	71fb      	strb	r3, [r7, #7]

  /* Return Page1 erase operation status */
  return FlashStatus;
 8001bb6:	79fb      	ldrb	r3, [r7, #7]
}
 8001bb8:	4618      	mov	r0, r3
 8001bba:	3708      	adds	r7, #8
 8001bbc:	46bd      	mov	sp, r7
 8001bbe:	bd80      	pop	{r7, pc}
 8001bc0:	08020000 	.word	0x08020000

08001bc4 <EE_FindValidPage>:
  *     @arg WRITE_IN_VALID_PAGE: write operation from valid page
  * @retval Valid page number (PAGE or PAGE1) or NO_VALID_PAGE in case
  *   of no valid page was found
  */
static uint16_t EE_FindValidPage(uint8_t Operation)
{
 8001bc4:	b480      	push	{r7}
 8001bc6:	b085      	sub	sp, #20
 8001bc8:	af00      	add	r7, sp, #0
 8001bca:	4603      	mov	r3, r0
 8001bcc:	71fb      	strb	r3, [r7, #7]
  uint16_t PageStatus0 = 6, PageStatus1 = 6;
 8001bce:	2306      	movs	r3, #6
 8001bd0:	81fb      	strh	r3, [r7, #14]
 8001bd2:	2306      	movs	r3, #6
 8001bd4:	81bb      	strh	r3, [r7, #12]

  /* Get Page0 actual status */
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8001bd6:	4b1c      	ldr	r3, [pc, #112]	; (8001c48 <EE_FindValidPage+0x84>)
 8001bd8:	881b      	ldrh	r3, [r3, #0]
 8001bda:	81fb      	strh	r3, [r7, #14]

  /* Get Page1 actual status */
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8001bdc:	4b1b      	ldr	r3, [pc, #108]	; (8001c4c <EE_FindValidPage+0x88>)
 8001bde:	881b      	ldrh	r3, [r3, #0]
 8001be0:	81bb      	strh	r3, [r7, #12]

  /* Write or read operation */
  switch (Operation)
 8001be2:	79fb      	ldrb	r3, [r7, #7]
 8001be4:	2b00      	cmp	r3, #0
 8001be6:	d01b      	beq.n	8001c20 <EE_FindValidPage+0x5c>
 8001be8:	2b01      	cmp	r3, #1
 8001bea:	d125      	bne.n	8001c38 <EE_FindValidPage+0x74>
  {
    case WRITE_IN_VALID_PAGE:   /* ---- Write operation ---- */
      if (PageStatus1 == VALID_PAGE)
 8001bec:	89bb      	ldrh	r3, [r7, #12]
 8001bee:	2b00      	cmp	r3, #0
 8001bf0:	d108      	bne.n	8001c04 <EE_FindValidPage+0x40>
      {
        /* Page0 receiving data */
        if (PageStatus0 == RECEIVE_DATA)
 8001bf2:	89fb      	ldrh	r3, [r7, #14]
 8001bf4:	f64e 62ee 	movw	r2, #61166	; 0xeeee
 8001bf8:	4293      	cmp	r3, r2
 8001bfa:	d101      	bne.n	8001c00 <EE_FindValidPage+0x3c>
        {
          return PAGE0;         /* Page0 valid */
 8001bfc:	2300      	movs	r3, #0
 8001bfe:	e01c      	b.n	8001c3a <EE_FindValidPage+0x76>
        }
        else
        {
          return PAGE1;         /* Page1 valid */
 8001c00:	2301      	movs	r3, #1
 8001c02:	e01a      	b.n	8001c3a <EE_FindValidPage+0x76>
        }
      }
      else if (PageStatus0 == VALID_PAGE)
 8001c04:	89fb      	ldrh	r3, [r7, #14]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	d108      	bne.n	8001c1c <EE_FindValidPage+0x58>
      {
        /* Page1 receiving data */
        if (PageStatus1 == RECEIVE_DATA)
 8001c0a:	89bb      	ldrh	r3, [r7, #12]
 8001c0c:	f64e 62ee 	movw	r2, #61166	; 0xeeee
 8001c10:	4293      	cmp	r3, r2
 8001c12:	d101      	bne.n	8001c18 <EE_FindValidPage+0x54>
        {
          return PAGE1;         /* Page1 valid */
 8001c14:	2301      	movs	r3, #1
 8001c16:	e010      	b.n	8001c3a <EE_FindValidPage+0x76>
        }
        else
        {
          return PAGE0;         /* Page0 valid */
 8001c18:	2300      	movs	r3, #0
 8001c1a:	e00e      	b.n	8001c3a <EE_FindValidPage+0x76>
        }
      }
      else
      {
        return NO_VALID_PAGE;   /* No valid Page */
 8001c1c:	23ab      	movs	r3, #171	; 0xab
 8001c1e:	e00c      	b.n	8001c3a <EE_FindValidPage+0x76>
      }

    case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
      if (PageStatus0 == VALID_PAGE)
 8001c20:	89fb      	ldrh	r3, [r7, #14]
 8001c22:	2b00      	cmp	r3, #0
 8001c24:	d101      	bne.n	8001c2a <EE_FindValidPage+0x66>
      {
        return PAGE0;           /* Page0 valid */
 8001c26:	2300      	movs	r3, #0
 8001c28:	e007      	b.n	8001c3a <EE_FindValidPage+0x76>
      }
      else if (PageStatus1 == VALID_PAGE)
 8001c2a:	89bb      	ldrh	r3, [r7, #12]
 8001c2c:	2b00      	cmp	r3, #0
 8001c2e:	d101      	bne.n	8001c34 <EE_FindValidPage+0x70>
      {
        return PAGE1;           /* Page1 valid */
 8001c30:	2301      	movs	r3, #1
 8001c32:	e002      	b.n	8001c3a <EE_FindValidPage+0x76>
      }
      else
      {
        return NO_VALID_PAGE ;  /* No valid Page */
 8001c34:	23ab      	movs	r3, #171	; 0xab
 8001c36:	e000      	b.n	8001c3a <EE_FindValidPage+0x76>
      }

    default:
      return PAGE0;             /* Page0 valid */
 8001c38:	2300      	movs	r3, #0
  }
}
 8001c3a:	4618      	mov	r0, r3
 8001c3c:	3714      	adds	r7, #20
 8001c3e:	46bd      	mov	sp, r7
 8001c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c44:	4770      	bx	lr
 8001c46:	bf00      	nop
 8001c48:	08020000 	.word	0x08020000
 8001c4c:	0803f400 	.word	0x0803f400

08001c50 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 8001c50:	b580      	push	{r7, lr}
 8001c52:	b086      	sub	sp, #24
 8001c54:	af00      	add	r7, sp, #0
 8001c56:	4603      	mov	r3, r0
 8001c58:	460a      	mov	r2, r1
 8001c5a:	80fb      	strh	r3, [r7, #6]
 8001c5c:	4613      	mov	r3, r2
 8001c5e:	80bb      	strh	r3, [r7, #4]
  FLASH_Status FlashStatus = FLASH_COMPLETE;
 8001c60:	2308      	movs	r3, #8
 8001c62:	74fb      	strb	r3, [r7, #19]
  uint16_t ValidPage = PAGE0;
 8001c64:	2300      	movs	r3, #0
 8001c66:	823b      	strh	r3, [r7, #16]
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;
 8001c68:	4b26      	ldr	r3, [pc, #152]	; (8001d04 <EE_VerifyPageFullWriteVariable+0xb4>)
 8001c6a:	617b      	str	r3, [r7, #20]
 8001c6c:	4b26      	ldr	r3, [pc, #152]	; (8001d08 <EE_VerifyPageFullWriteVariable+0xb8>)
 8001c6e:	60fb      	str	r3, [r7, #12]

  /* Get valid Page for write operation */
  ValidPage = EE_FindValidPage(WRITE_IN_VALID_PAGE);
 8001c70:	2001      	movs	r0, #1
 8001c72:	f7ff ffa7 	bl	8001bc4 <EE_FindValidPage>
 8001c76:	4603      	mov	r3, r0
 8001c78:	823b      	strh	r3, [r7, #16]

  /* Check if there is no valid page */
  if (ValidPage == NO_VALID_PAGE)
 8001c7a:	8a3b      	ldrh	r3, [r7, #16]
 8001c7c:	2bab      	cmp	r3, #171	; 0xab
 8001c7e:	d101      	bne.n	8001c84 <EE_VerifyPageFullWriteVariable+0x34>
  {
    return  NO_VALID_PAGE;
 8001c80:	23ab      	movs	r3, #171	; 0xab
 8001c82:	e03a      	b.n	8001cfa <EE_VerifyPageFullWriteVariable+0xaa>
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8001c84:	8a3b      	ldrh	r3, [r7, #16]
 8001c86:	f44f 32fa 	mov.w	r2, #128000	; 0x1f400
 8001c8a:	fb02 f303 	mul.w	r3, r2, r3
 8001c8e:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8001c92:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8001c96:	617b      	str	r3, [r7, #20]

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 8001c98:	8a3b      	ldrh	r3, [r7, #16]
 8001c9a:	3301      	adds	r3, #1
 8001c9c:	461a      	mov	r2, r3
 8001c9e:	f44f 33fa 	mov.w	r3, #128000	; 0x1f400
 8001ca2:	fb03 f202 	mul.w	r2, r3, r2
 8001ca6:	4b19      	ldr	r3, [pc, #100]	; (8001d0c <EE_VerifyPageFullWriteVariable+0xbc>)
 8001ca8:	4413      	add	r3, r2
 8001caa:	60fb      	str	r3, [r7, #12]

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 8001cac:	e020      	b.n	8001cf0 <EE_VerifyPageFullWriteVariable+0xa0>
  {
    /* Verify if Address and Address+2 contents are 0xFFFFFFFF */
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8001cae:	697b      	ldr	r3, [r7, #20]
 8001cb0:	681b      	ldr	r3, [r3, #0]
 8001cb2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001cb6:	d118      	bne.n	8001cea <EE_VerifyPageFullWriteVariable+0x9a>
    {
      /* Set variable data */
      FlashStatus = FLASH_ProgramHalfWord(Address, Data);
 8001cb8:	88bb      	ldrh	r3, [r7, #4]
 8001cba:	4619      	mov	r1, r3
 8001cbc:	6978      	ldr	r0, [r7, #20]
 8001cbe:	f7fe fbff 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001cc2:	4603      	mov	r3, r0
 8001cc4:	74fb      	strb	r3, [r7, #19]
      /* If program operation was failed, a Flash error code is returned */
      if (FlashStatus != FLASH_COMPLETE)
 8001cc6:	7cfb      	ldrb	r3, [r7, #19]
 8001cc8:	2b08      	cmp	r3, #8
 8001cca:	d002      	beq.n	8001cd2 <EE_VerifyPageFullWriteVariable+0x82>
      {
        return FlashStatus;
 8001ccc:	7cfb      	ldrb	r3, [r7, #19]
 8001cce:	b29b      	uxth	r3, r3
 8001cd0:	e013      	b.n	8001cfa <EE_VerifyPageFullWriteVariable+0xaa>
      }
      /* Set variable virtual address */
      FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
 8001cd2:	697b      	ldr	r3, [r7, #20]
 8001cd4:	3302      	adds	r3, #2
 8001cd6:	88fa      	ldrh	r2, [r7, #6]
 8001cd8:	4611      	mov	r1, r2
 8001cda:	4618      	mov	r0, r3
 8001cdc:	f7fe fbf0 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001ce0:	4603      	mov	r3, r0
 8001ce2:	74fb      	strb	r3, [r7, #19]
      /* Return program operation status */
      return FlashStatus;
 8001ce4:	7cfb      	ldrb	r3, [r7, #19]
 8001ce6:	b29b      	uxth	r3, r3
 8001ce8:	e007      	b.n	8001cfa <EE_VerifyPageFullWriteVariable+0xaa>
    }
    else
    {
      /* Next address location */
      Address = Address + 4;
 8001cea:	697b      	ldr	r3, [r7, #20]
 8001cec:	3304      	adds	r3, #4
 8001cee:	617b      	str	r3, [r7, #20]

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 8001cf0:	697a      	ldr	r2, [r7, #20]
 8001cf2:	68fb      	ldr	r3, [r7, #12]
 8001cf4:	429a      	cmp	r2, r3
 8001cf6:	d3da      	bcc.n	8001cae <EE_VerifyPageFullWriteVariable+0x5e>
      Address = Address + 4;
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
 8001cf8:	2380      	movs	r3, #128	; 0x80
}
 8001cfa:	4618      	mov	r0, r3
 8001cfc:	3718      	adds	r7, #24
 8001cfe:	46bd      	mov	sp, r7
 8001d00:	bd80      	pop	{r7, pc}
 8001d02:	bf00      	nop
 8001d04:	08020000 	.word	0x08020000
 8001d08:	0803f400 	.word	0x0803f400
 8001d0c:	0801fffe 	.word	0x0801fffe

08001d10 <EE_PageTransfer>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_PageTransfer(uint16_t VirtAddress, uint16_t Data)
{
 8001d10:	b580      	push	{r7, lr}
 8001d12:	b086      	sub	sp, #24
 8001d14:	af00      	add	r7, sp, #0
 8001d16:	4603      	mov	r3, r0
 8001d18:	460a      	mov	r2, r1
 8001d1a:	80fb      	strh	r3, [r7, #6]
 8001d1c:	4613      	mov	r3, r2
 8001d1e:	80bb      	strh	r3, [r7, #4]
  FLASH_Status FlashStatus = FLASH_COMPLETE;
 8001d20:	2308      	movs	r3, #8
 8001d22:	73fb      	strb	r3, [r7, #15]
  uint32_t NewPageAddress = EEPROM_START_ADDRESS;
 8001d24:	4b44      	ldr	r3, [pc, #272]	; (8001e38 <EE_PageTransfer+0x128>)
 8001d26:	617b      	str	r3, [r7, #20]
  uint16_t OldPageId=0;
 8001d28:	2300      	movs	r3, #0
 8001d2a:	827b      	strh	r3, [r7, #18]
  uint16_t ValidPage = PAGE0, VarIdx = 0;
 8001d2c:	2300      	movs	r3, #0
 8001d2e:	81bb      	strh	r3, [r7, #12]
 8001d30:	2300      	movs	r3, #0
 8001d32:	823b      	strh	r3, [r7, #16]
  uint16_t EepromStatus = 0, ReadStatus = 0;
 8001d34:	2300      	movs	r3, #0
 8001d36:	817b      	strh	r3, [r7, #10]
 8001d38:	2300      	movs	r3, #0
 8001d3a:	813b      	strh	r3, [r7, #8]

  /* Get active Page for read operation */
  ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
 8001d3c:	2000      	movs	r0, #0
 8001d3e:	f7ff ff41 	bl	8001bc4 <EE_FindValidPage>
 8001d42:	4603      	mov	r3, r0
 8001d44:	81bb      	strh	r3, [r7, #12]

  if (ValidPage == PAGE1)       /* Page1 valid */
 8001d46:	89bb      	ldrh	r3, [r7, #12]
 8001d48:	2b01      	cmp	r3, #1
 8001d4a:	d104      	bne.n	8001d56 <EE_PageTransfer+0x46>
  {
    /* New page address where variable will be moved to */
    NewPageAddress = PAGE0_BASE_ADDRESS;
 8001d4c:	4b3a      	ldr	r3, [pc, #232]	; (8001e38 <EE_PageTransfer+0x128>)
 8001d4e:	617b      	str	r3, [r7, #20]

    /* Old page ID where variable will be taken from */
    OldPageId = PAGE1_ID;
 8001d50:	2318      	movs	r3, #24
 8001d52:	827b      	strh	r3, [r7, #18]
 8001d54:	e009      	b.n	8001d6a <EE_PageTransfer+0x5a>
  }
  else if (ValidPage == PAGE0)  /* Page0 valid */
 8001d56:	89bb      	ldrh	r3, [r7, #12]
 8001d58:	2b00      	cmp	r3, #0
 8001d5a:	d104      	bne.n	8001d66 <EE_PageTransfer+0x56>
  {
    /* New page address  where variable will be moved to */
    NewPageAddress = PAGE1_BASE_ADDRESS;
 8001d5c:	4b37      	ldr	r3, [pc, #220]	; (8001e3c <EE_PageTransfer+0x12c>)
 8001d5e:	617b      	str	r3, [r7, #20]

    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
 8001d60:	2310      	movs	r3, #16
 8001d62:	827b      	strh	r3, [r7, #18]
 8001d64:	e001      	b.n	8001d6a <EE_PageTransfer+0x5a>
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
 8001d66:	23ab      	movs	r3, #171	; 0xab
 8001d68:	e062      	b.n	8001e30 <EE_PageTransfer+0x120>
  }

  /* Set the new Page status to RECEIVE_DATA status */
  FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
 8001d6a:	f64e 61ee 	movw	r1, #61166	; 0xeeee
 8001d6e:	6978      	ldr	r0, [r7, #20]
 8001d70:	f7fe fba6 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001d74:	4603      	mov	r3, r0
 8001d76:	73fb      	strb	r3, [r7, #15]
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8001d78:	7bfb      	ldrb	r3, [r7, #15]
 8001d7a:	2b08      	cmp	r3, #8
 8001d7c:	d002      	beq.n	8001d84 <EE_PageTransfer+0x74>
  {
    return FlashStatus;
 8001d7e:	7bfb      	ldrb	r3, [r7, #15]
 8001d80:	b29b      	uxth	r3, r3
 8001d82:	e055      	b.n	8001e30 <EE_PageTransfer+0x120>
  }

  /* Write the variable passed as parameter in the new active page */
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8001d84:	88ba      	ldrh	r2, [r7, #4]
 8001d86:	88fb      	ldrh	r3, [r7, #6]
 8001d88:	4611      	mov	r1, r2
 8001d8a:	4618      	mov	r0, r3
 8001d8c:	f7ff ff60 	bl	8001c50 <EE_VerifyPageFullWriteVariable>
 8001d90:	4603      	mov	r3, r0
 8001d92:	817b      	strh	r3, [r7, #10]
  /* If program operation was failed, a Flash error code is returned */
  if (EepromStatus != FLASH_COMPLETE)
 8001d94:	897b      	ldrh	r3, [r7, #10]
 8001d96:	2b08      	cmp	r3, #8
 8001d98:	d001      	beq.n	8001d9e <EE_PageTransfer+0x8e>
  {
    return EepromStatus;
 8001d9a:	897b      	ldrh	r3, [r7, #10]
 8001d9c:	e048      	b.n	8001e30 <EE_PageTransfer+0x120>
  }

  /* Transfer process: transfer variables from old to the new active page */
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8001d9e:	2300      	movs	r3, #0
 8001da0:	823b      	strh	r3, [r7, #16]
 8001da2:	e027      	b.n	8001df4 <EE_PageTransfer+0xe4>
  {
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8001da4:	8a3b      	ldrh	r3, [r7, #16]
 8001da6:	4a26      	ldr	r2, [pc, #152]	; (8001e40 <EE_PageTransfer+0x130>)
 8001da8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001dac:	88fa      	ldrh	r2, [r7, #6]
 8001dae:	429a      	cmp	r2, r3
 8001db0:	d01d      	beq.n	8001dee <EE_PageTransfer+0xde>
    {
      /* Read the other last variable updates */
      ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8001db2:	8a3b      	ldrh	r3, [r7, #16]
 8001db4:	4a22      	ldr	r2, [pc, #136]	; (8001e40 <EE_PageTransfer+0x130>)
 8001db6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001dba:	4922      	ldr	r1, [pc, #136]	; (8001e44 <EE_PageTransfer+0x134>)
 8001dbc:	4618      	mov	r0, r3
 8001dbe:	f7ff fe65 	bl	8001a8c <EE_ReadVariable>
 8001dc2:	4603      	mov	r3, r0
 8001dc4:	813b      	strh	r3, [r7, #8]
      /* In case variable corresponding to the virtual address was found */
      if (ReadStatus != 0x1)
 8001dc6:	893b      	ldrh	r3, [r7, #8]
 8001dc8:	2b01      	cmp	r3, #1
 8001dca:	d010      	beq.n	8001dee <EE_PageTransfer+0xde>
      {
        /* Transfer the variable to the new active page */
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8001dcc:	8a3b      	ldrh	r3, [r7, #16]
 8001dce:	4a1c      	ldr	r2, [pc, #112]	; (8001e40 <EE_PageTransfer+0x130>)
 8001dd0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 8001dd4:	4b1b      	ldr	r3, [pc, #108]	; (8001e44 <EE_PageTransfer+0x134>)
 8001dd6:	881b      	ldrh	r3, [r3, #0]
 8001dd8:	4619      	mov	r1, r3
 8001dda:	4610      	mov	r0, r2
 8001ddc:	f7ff ff38 	bl	8001c50 <EE_VerifyPageFullWriteVariable>
 8001de0:	4603      	mov	r3, r0
 8001de2:	817b      	strh	r3, [r7, #10]
        /* If program operation was failed, a Flash error code is returned */
        if (EepromStatus != FLASH_COMPLETE)
 8001de4:	897b      	ldrh	r3, [r7, #10]
 8001de6:	2b08      	cmp	r3, #8
 8001de8:	d001      	beq.n	8001dee <EE_PageTransfer+0xde>
        {
          return EepromStatus;
 8001dea:	897b      	ldrh	r3, [r7, #10]
 8001dec:	e020      	b.n	8001e30 <EE_PageTransfer+0x120>
  {
    return EepromStatus;
  }

  /* Transfer process: transfer variables from old to the new active page */
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8001dee:	8a3b      	ldrh	r3, [r7, #16]
 8001df0:	3301      	adds	r3, #1
 8001df2:	823b      	strh	r3, [r7, #16]
 8001df4:	8a3b      	ldrh	r3, [r7, #16]
 8001df6:	2b02      	cmp	r3, #2
 8001df8:	d9d4      	bls.n	8001da4 <EE_PageTransfer+0x94>
      }
    }
  }

  /* Erase the old Page: Set old Page status to ERASED status */
  FlashStatus = FLASH_EraseSector(OldPageId, VOLTAGE_RANGE);
 8001dfa:	8a7b      	ldrh	r3, [r7, #18]
 8001dfc:	2102      	movs	r1, #2
 8001dfe:	4618      	mov	r0, r3
 8001e00:	f7fe fafe 	bl	8000400 <FLASH_EraseSector>
 8001e04:	4603      	mov	r3, r0
 8001e06:	73fb      	strb	r3, [r7, #15]
  /* If erase operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8001e08:	7bfb      	ldrb	r3, [r7, #15]
 8001e0a:	2b08      	cmp	r3, #8
 8001e0c:	d002      	beq.n	8001e14 <EE_PageTransfer+0x104>
  {
    return FlashStatus;
 8001e0e:	7bfb      	ldrb	r3, [r7, #15]
 8001e10:	b29b      	uxth	r3, r3
 8001e12:	e00d      	b.n	8001e30 <EE_PageTransfer+0x120>
  }

  /* Set new Page status to VALID_PAGE status */
  FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
 8001e14:	2100      	movs	r1, #0
 8001e16:	6978      	ldr	r0, [r7, #20]
 8001e18:	f7fe fb52 	bl	80004c0 <FLASH_ProgramHalfWord>
 8001e1c:	4603      	mov	r3, r0
 8001e1e:	73fb      	strb	r3, [r7, #15]
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8001e20:	7bfb      	ldrb	r3, [r7, #15]
 8001e22:	2b08      	cmp	r3, #8
 8001e24:	d002      	beq.n	8001e2c <EE_PageTransfer+0x11c>
  {
    return FlashStatus;
 8001e26:	7bfb      	ldrb	r3, [r7, #15]
 8001e28:	b29b      	uxth	r3, r3
 8001e2a:	e001      	b.n	8001e30 <EE_PageTransfer+0x120>
  }

  /* Return last operation flash status */
  return FlashStatus;
 8001e2c:	7bfb      	ldrb	r3, [r7, #15]
 8001e2e:	b29b      	uxth	r3, r3
}
 8001e30:	4618      	mov	r0, r3
 8001e32:	3718      	adds	r7, #24
 8001e34:	46bd      	mov	sp, r7
 8001e36:	bd80      	pop	{r7, pc}
 8001e38:	08020000 	.word	0x08020000
 8001e3c:	0803f400 	.word	0x0803f400
 8001e40:	20000020 	.word	0x20000020
 8001e44:	20000058 	.word	0x20000058

08001e48 <main>:
RTC_TimeTypeDef ttime;
RTC_AlarmTypeDef alarmA;

void init_RCC_Clock(void);
int main(void)
{
 8001e48:	b580      	push	{r7, lr}
 8001e4a:	b084      	sub	sp, #16
 8001e4c:	af00      	add	r7, sp, #0
		/* Check if software reset has occurred */
		STM_EVAL_LEDInit(LED3);
 8001e4e:	2001      	movs	r0, #1
 8001e50:	f7ff fb70 	bl	8001534 <STM_EVAL_LEDInit>
		RCC_ClocksTypeDef Clockf;
		RCC_GetClocksFreq(&Clockf);
 8001e54:	463b      	mov	r3, r7
 8001e56:	4618      	mov	r0, r3
 8001e58:	f7fe fd9c 	bl	8000994 <RCC_GetClocksFreq>
		init_RCC_Clock();
 8001e5c:	f000 f882 	bl	8001f64 <init_RCC_Clock>
		RCC_GetClocksFreq(&Clockf);
 8001e60:	463b      	mov	r3, r7
 8001e62:	4618      	mov	r0, r3
 8001e64:	f7fe fd96 	bl	8000994 <RCC_GetClocksFreq>
		if(PWR_GetFlagStatus(PWR_FLAG_WU) == SET)
 8001e68:	2001      	movs	r0, #1
 8001e6a:	f7fe fc49 	bl	8000700 <PWR_GetFlagStatus>
 8001e6e:	4603      	mov	r3, r0
 8001e70:	2b01      	cmp	r3, #1
 8001e72:	d136      	bne.n	8001ee2 <main+0x9a>
		{
			/* check if source came from alarm flag*/
			if(RTC_GetFlagStatus(RTC_FLAG_ALRAF) == SET)
 8001e74:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001e78:	f7ff faca 	bl	8001410 <RTC_GetFlagStatus>
 8001e7c:	4603      	mov	r3, r0
 8001e7e:	2b01      	cmp	r3, #1
 8001e80:	d12b      	bne.n	8001eda <main+0x92>
			{
				/* Disable Power*/
				RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR,DISABLE);
 8001e82:	2100      	movs	r1, #0
 8001e84:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8001e88:	f7fe fecc 	bl	8000c24 <RCC_APB1PeriphResetCmd>
				/* Enable access to back up registers*/
				PWR_BackupAccessCmd(ENABLE);
 8001e8c:	2001      	movs	r0, #1
 8001e8e:	f7fe fc27 	bl	80006e0 <PWR_BackupAccessCmd>
				// read block at virtual address
				FLASH_Unlock();
 8001e92:	f7fe fa8d 	bl	80003b0 <FLASH_Unlock>
				EE_Init();
 8001e96:	f7ff fca1 	bl	80017dc <EE_Init>

				if(EE_ReadVariable(VirtAddVarTab[0],&VarValue))
 8001e9a:	4b2d      	ldr	r3, [pc, #180]	; (8001f50 <main+0x108>)
 8001e9c:	881b      	ldrh	r3, [r3, #0]
 8001e9e:	492d      	ldr	r1, [pc, #180]	; (8001f54 <main+0x10c>)
 8001ea0:	4618      	mov	r0, r3
 8001ea2:	f7ff fdf3 	bl	8001a8c <EE_ReadVariable>
 8001ea6:	4603      	mov	r3, r0
 8001ea8:	2b00      	cmp	r3, #0
 8001eaa:	d006      	beq.n	8001eba <main+0x72>
				{
					EE_WriteVariable(VirtAddVarTab[0],0x1);
 8001eac:	4b28      	ldr	r3, [pc, #160]	; (8001f50 <main+0x108>)
 8001eae:	881b      	ldrh	r3, [r3, #0]
 8001eb0:	2101      	movs	r1, #1
 8001eb2:	4618      	mov	r0, r3
 8001eb4:	f7ff fe3c 	bl	8001b30 <EE_WriteVariable>
 8001eb8:	e00d      	b.n	8001ed6 <main+0x8e>
				}
				else
				{
					VarValue++;
 8001eba:	4b26      	ldr	r3, [pc, #152]	; (8001f54 <main+0x10c>)
 8001ebc:	881b      	ldrh	r3, [r3, #0]
 8001ebe:	3301      	adds	r3, #1
 8001ec0:	b29a      	uxth	r2, r3
 8001ec2:	4b24      	ldr	r3, [pc, #144]	; (8001f54 <main+0x10c>)
 8001ec4:	801a      	strh	r2, [r3, #0]
					EE_WriteVariable(VirtAddVarTab[0],VarValue);
 8001ec6:	4b22      	ldr	r3, [pc, #136]	; (8001f50 <main+0x108>)
 8001ec8:	881a      	ldrh	r2, [r3, #0]
 8001eca:	4b22      	ldr	r3, [pc, #136]	; (8001f54 <main+0x10c>)
 8001ecc:	881b      	ldrh	r3, [r3, #0]
 8001ece:	4619      	mov	r1, r3
 8001ed0:	4610      	mov	r0, r2
 8001ed2:	f7ff fe2d 	bl	8001b30 <EE_WriteVariable>
				}
				FLASH_Lock();
 8001ed6:	f7fe fa83 	bl	80003e0 <FLASH_Lock>
			}
			PWR_ClearFlag(PWR_FLAG_WU);
 8001eda:	2001      	movs	r0, #1
 8001edc:	f7fe fc2a 	bl	8000734 <PWR_ClearFlag>
 8001ee0:	e001      	b.n	8001ee6 <main+0x9e>

		}else
		{
			init_RTC();
 8001ee2:	f7ff fb87 	bl	80015f4 <init_RTC>
		}
		RTC_GetTime(RTC_Format_BIN,&Atime);
 8001ee6:	491c      	ldr	r1, [pc, #112]	; (8001f58 <main+0x110>)
 8001ee8:	2000      	movs	r0, #0
 8001eea:	f7ff f871 	bl	8000fd0 <RTC_GetTime>
		alarmA.RTC_AlarmMask = (RTC_AlarmMask_Hours | RTC_AlarmMask_DateWeekDay | RTC_AlarmMask_Minutes);
 8001eee:	4b1b      	ldr	r3, [pc, #108]	; (8001f5c <main+0x114>)
 8001ef0:	4a1b      	ldr	r2, [pc, #108]	; (8001f60 <main+0x118>)
 8001ef2:	605a      	str	r2, [r3, #4]
		Atime.RTC_Seconds+= 15;
 8001ef4:	4b18      	ldr	r3, [pc, #96]	; (8001f58 <main+0x110>)
 8001ef6:	789b      	ldrb	r3, [r3, #2]
 8001ef8:	330f      	adds	r3, #15
 8001efa:	b2da      	uxtb	r2, r3
 8001efc:	4b16      	ldr	r3, [pc, #88]	; (8001f58 <main+0x110>)
 8001efe:	709a      	strb	r2, [r3, #2]
		if(Atime.RTC_Seconds > 59)
 8001f00:	4b15      	ldr	r3, [pc, #84]	; (8001f58 <main+0x110>)
 8001f02:	789b      	ldrb	r3, [r3, #2]
 8001f04:	2b3b      	cmp	r3, #59	; 0x3b
 8001f06:	d90b      	bls.n	8001f20 <main+0xd8>
		{
			Atime.RTC_Seconds -= 60; //add a minute
 8001f08:	4b13      	ldr	r3, [pc, #76]	; (8001f58 <main+0x110>)
 8001f0a:	789b      	ldrb	r3, [r3, #2]
 8001f0c:	3b3c      	subs	r3, #60	; 0x3c
 8001f0e:	b2da      	uxtb	r2, r3
 8001f10:	4b11      	ldr	r3, [pc, #68]	; (8001f58 <main+0x110>)
 8001f12:	709a      	strb	r2, [r3, #2]
			Atime.RTC_Minutes += 1;
 8001f14:	4b10      	ldr	r3, [pc, #64]	; (8001f58 <main+0x110>)
 8001f16:	785b      	ldrb	r3, [r3, #1]
 8001f18:	3301      	adds	r3, #1
 8001f1a:	b2da      	uxtb	r2, r3
 8001f1c:	4b0e      	ldr	r3, [pc, #56]	; (8001f58 <main+0x110>)
 8001f1e:	705a      	strb	r2, [r3, #1]
		}
		if(Atime.RTC_Minutes > 59)
 8001f20:	4b0d      	ldr	r3, [pc, #52]	; (8001f58 <main+0x110>)
 8001f22:	785b      	ldrb	r3, [r3, #1]
 8001f24:	2b3b      	cmp	r3, #59	; 0x3b
 8001f26:	d908      	bls.n	8001f3a <main+0xf2>
		{
			Atime.RTC_Minutes = 0;
 8001f28:	4b0b      	ldr	r3, [pc, #44]	; (8001f58 <main+0x110>)
 8001f2a:	2200      	movs	r2, #0
 8001f2c:	705a      	strb	r2, [r3, #1]
			Atime.RTC_Hours++;
 8001f2e:	4b0a      	ldr	r3, [pc, #40]	; (8001f58 <main+0x110>)
 8001f30:	781b      	ldrb	r3, [r3, #0]
 8001f32:	3301      	adds	r3, #1
 8001f34:	b2da      	uxtb	r2, r3
 8001f36:	4b08      	ldr	r3, [pc, #32]	; (8001f58 <main+0x110>)
 8001f38:	701a      	strb	r2, [r3, #0]
		}

		set_RTCAlarm_A(&Atime,&alarmA);
 8001f3a:	4908      	ldr	r1, [pc, #32]	; (8001f5c <main+0x114>)
 8001f3c:	4806      	ldr	r0, [pc, #24]	; (8001f58 <main+0x110>)
 8001f3e:	f7ff fb9b 	bl	8001678 <set_RTCAlarm_A>
		STM_EVAL_LEDOn(LED3);
 8001f42:	2001      	movs	r0, #1
 8001f44:	f7ff fb24 	bl	8001590 <STM_EVAL_LEDOn>
		//add one minute

	while(1)
	{

			set_StdBy_Mode();
 8001f48:	f7ff fc06 	bl	8001758 <set_StdBy_Mode>

	}
 8001f4c:	e7fc      	b.n	8001f48 <main+0x100>
 8001f4e:	bf00      	nop
 8001f50:	20000020 	.word	0x20000020
 8001f54:	2000005a 	.word	0x2000005a
 8001f58:	2000005c 	.word	0x2000005c
 8001f5c:	20000064 	.word	0x20000064
 8001f60:	80808000 	.word	0x80808000

08001f64 <init_RCC_Clock>:
}

void init_RCC_Clock(void)
{
 8001f64:	b580      	push	{r7, lr}
 8001f66:	b084      	sub	sp, #16
 8001f68:	af02      	add	r7, sp, #8
	/* Set RCC value to default state*/
	RCC_DeInit();
 8001f6a:	f7fe fbf7 	bl	800075c <RCC_DeInit>
	/* Enable external Crystal Oscilator*/
	RCC_HSEConfig(RCC_HSE_ON);
 8001f6e:	2001      	movs	r0, #1
 8001f70:	f7fe fc22 	bl	80007b8 <RCC_HSEConfig>
	ErrorStatus errorstatus = RCC_WaitForHSEStartUp();
 8001f74:	f7fe fc34 	bl	80007e0 <RCC_WaitForHSEStartUp>
 8001f78:	4603      	mov	r3, r0
 8001f7a:	71fb      	strb	r3, [r7, #7]
	if(errorstatus == SUCCESS)
 8001f7c:	79fb      	ldrb	r3, [r7, #7]
 8001f7e:	2b01      	cmp	r3, #1
 8001f80:	d123      	bne.n	8001fca <init_RCC_Clock+0x66>
	{
		/* Configure PLL clock for 48 MHz*/
		RCC_PLLConfig(RCC_PLLSource_HSE,4,192,8,8);
 8001f82:	2308      	movs	r3, #8
 8001f84:	9300      	str	r3, [sp, #0]
 8001f86:	2308      	movs	r3, #8
 8001f88:	22c0      	movs	r2, #192	; 0xc0
 8001f8a:	2104      	movs	r1, #4
 8001f8c:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8001f90:	f7fe fc5e 	bl	8000850 <RCC_PLLConfig>
		/* enable pll and wait until ready*/
		RCC_PLLCmd(ENABLE);
 8001f94:	2001      	movs	r0, #1
 8001f96:	f7fe fc7b 	bl	8000890 <RCC_PLLCmd>
		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
 8001f9a:	bf00      	nop
 8001f9c:	2039      	movs	r0, #57	; 0x39
 8001f9e:	f7fe fe61 	bl	8000c64 <RCC_GetFlagStatus>
 8001fa2:	4603      	mov	r3, r0
 8001fa4:	2b00      	cmp	r3, #0
 8001fa6:	d0f9      	beq.n	8001f9c <init_RCC_Clock+0x38>

		/* Set Flash Latency*/
		FLASH_SetLatency(FLASH_Latency_1);
 8001fa8:	2001      	movs	r0, #1
 8001faa:	f7fe f9f1 	bl	8000390 <FLASH_SetLatency>
		/* Set AHB prescaler*/
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 8001fae:	2000      	movs	r0, #0
 8001fb0:	f7fe fc9a 	bl	80008e8 <RCC_HCLKConfig>
		/* Set APB1 Scaler */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 8001fb4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001fb8:	f7fe fcb2 	bl	8000920 <RCC_PCLK1Config>
		/* Set APB2 Scaler*/
		RCC_PCLK2Config(RCC_HCLK_Div1);
 8001fbc:	2000      	movs	r0, #0
 8001fbe:	f7fe fccb 	bl	8000958 <RCC_PCLK2Config>
		 /* Set Clock source to PLL*/
		 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 8001fc2:	2002      	movs	r0, #2
 8001fc4:	f7fe fc74 	bl	80008b0 <RCC_SYSCLKConfig>
 8001fc8:	e001      	b.n	8001fce <init_RCC_Clock+0x6a>

	}else
	{
			//Set clock source to default config
			RCC_DeInit();
 8001fca:	f7fe fbc7 	bl	800075c <RCC_DeInit>
	}
	SystemCoreClockUpdate();
 8001fce:	f000 f89d 	bl	800210c <SystemCoreClockUpdate>
}
 8001fd2:	bf00      	nop
 8001fd4:	3708      	adds	r7, #8
 8001fd6:	46bd      	mov	sp, r7
 8001fd8:	bd80      	pop	{r7, pc}
 8001fda:	bf00      	nop

08001fdc <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8001fdc:	f8df d034 	ldr.w	sp, [pc, #52]	; 8002014 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8001fe0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8001fe2:	e003      	b.n	8001fec <LoopCopyDataInit>

08001fe4 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8001fe4:	4b0c      	ldr	r3, [pc, #48]	; (8002018 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8001fe6:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001fe8:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001fea:	3104      	adds	r1, #4

08001fec <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001fec:	480b      	ldr	r0, [pc, #44]	; (800201c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8001fee:	4b0c      	ldr	r3, [pc, #48]	; (8002020 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8001ff0:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8001ff2:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8001ff4:	d3f6      	bcc.n	8001fe4 <CopyDataInit>
  ldr  r2, =_sbss
 8001ff6:	4a0b      	ldr	r2, [pc, #44]	; (8002024 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8001ff8:	e002      	b.n	8002000 <LoopFillZerobss>

08001ffa <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8001ffa:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8001ffc:	f842 3b04 	str.w	r3, [r2], #4

08002000 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002000:	4b09      	ldr	r3, [pc, #36]	; (8002028 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8002002:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8002004:	d3f9      	bcc.n	8001ffa <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8002006:	f000 f84b 	bl	80020a0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800200a:	f000 f979 	bl	8002300 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800200e:	f7ff ff1b 	bl	8001e48 <main>
  bx  lr    
 8002012:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002014:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8002018:	08002384 	.word	0x08002384
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800201c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8002020:	2000003c 	.word	0x2000003c
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8002024:	2000003c 	.word	0x2000003c
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002028:	20000074 	.word	0x20000074

0800202c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800202c:	e7fe      	b.n	800202c <ADC_IRQHandler>
	...

08002030 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8002030:	b480      	push	{r7}
 8002032:	af00      	add	r7, sp, #0
}
 8002034:	bf00      	nop
 8002036:	46bd      	mov	sp, r7
 8002038:	f85d 7b04 	ldr.w	r7, [sp], #4
 800203c:	4770      	bx	lr
 800203e:	bf00      	nop

08002040 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8002040:	b480      	push	{r7}
 8002042:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 8002044:	e7fe      	b.n	8002044 <HardFault_Handler+0x4>
 8002046:	bf00      	nop

08002048 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8002048:	b480      	push	{r7}
 800204a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 800204c:	e7fe      	b.n	800204c <MemManage_Handler+0x4>
 800204e:	bf00      	nop

08002050 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8002050:	b480      	push	{r7}
 8002052:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8002054:	e7fe      	b.n	8002054 <BusFault_Handler+0x4>
 8002056:	bf00      	nop

08002058 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002058:	b480      	push	{r7}
 800205a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 800205c:	e7fe      	b.n	800205c <UsageFault_Handler+0x4>
 800205e:	bf00      	nop

08002060 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8002060:	b480      	push	{r7}
 8002062:	af00      	add	r7, sp, #0
}
 8002064:	bf00      	nop
 8002066:	46bd      	mov	sp, r7
 8002068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800206c:	4770      	bx	lr
 800206e:	bf00      	nop

08002070 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8002070:	b480      	push	{r7}
 8002072:	af00      	add	r7, sp, #0
}
 8002074:	bf00      	nop
 8002076:	46bd      	mov	sp, r7
 8002078:	f85d 7b04 	ldr.w	r7, [sp], #4
 800207c:	4770      	bx	lr
 800207e:	bf00      	nop

08002080 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8002080:	b480      	push	{r7}
 8002082:	af00      	add	r7, sp, #0
}
 8002084:	bf00      	nop
 8002086:	46bd      	mov	sp, r7
 8002088:	f85d 7b04 	ldr.w	r7, [sp], #4
 800208c:	4770      	bx	lr
 800208e:	bf00      	nop

08002090 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8002090:	b480      	push	{r7}
 8002092:	af00      	add	r7, sp, #0
/*  TimingDelay_Decrement(); */
}
 8002094:	bf00      	nop
 8002096:	46bd      	mov	sp, r7
 8002098:	f85d 7b04 	ldr.w	r7, [sp], #4
 800209c:	4770      	bx	lr
 800209e:	bf00      	nop

080020a0 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80020a0:	b580      	push	{r7, lr}
 80020a2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80020a4:	4a16      	ldr	r2, [pc, #88]	; (8002100 <SystemInit+0x60>)
 80020a6:	4b16      	ldr	r3, [pc, #88]	; (8002100 <SystemInit+0x60>)
 80020a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80020ac:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80020b0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80020b4:	4a13      	ldr	r2, [pc, #76]	; (8002104 <SystemInit+0x64>)
 80020b6:	4b13      	ldr	r3, [pc, #76]	; (8002104 <SystemInit+0x64>)
 80020b8:	681b      	ldr	r3, [r3, #0]
 80020ba:	f043 0301 	orr.w	r3, r3, #1
 80020be:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80020c0:	4b10      	ldr	r3, [pc, #64]	; (8002104 <SystemInit+0x64>)
 80020c2:	2200      	movs	r2, #0
 80020c4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80020c6:	4a0f      	ldr	r2, [pc, #60]	; (8002104 <SystemInit+0x64>)
 80020c8:	4b0e      	ldr	r3, [pc, #56]	; (8002104 <SystemInit+0x64>)
 80020ca:	681b      	ldr	r3, [r3, #0]
 80020cc:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80020d0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80020d4:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80020d6:	4b0b      	ldr	r3, [pc, #44]	; (8002104 <SystemInit+0x64>)
 80020d8:	4a0b      	ldr	r2, [pc, #44]	; (8002108 <SystemInit+0x68>)
 80020da:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80020dc:	4a09      	ldr	r2, [pc, #36]	; (8002104 <SystemInit+0x64>)
 80020de:	4b09      	ldr	r3, [pc, #36]	; (8002104 <SystemInit+0x64>)
 80020e0:	681b      	ldr	r3, [r3, #0]
 80020e2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80020e6:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80020e8:	4b06      	ldr	r3, [pc, #24]	; (8002104 <SystemInit+0x64>)
 80020ea:	2200      	movs	r2, #0
 80020ec:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 80020ee:	f000 f88b 	bl	8002208 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80020f2:	4b03      	ldr	r3, [pc, #12]	; (8002100 <SystemInit+0x60>)
 80020f4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80020f8:	609a      	str	r2, [r3, #8]
#endif
}
 80020fa:	bf00      	nop
 80020fc:	bd80      	pop	{r7, pc}
 80020fe:	bf00      	nop
 8002100:	e000ed00 	.word	0xe000ed00
 8002104:	40023800 	.word	0x40023800
 8002108:	24003010 	.word	0x24003010

0800210c <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 800210c:	b480      	push	{r7}
 800210e:	b087      	sub	sp, #28
 8002110:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8002112:	2300      	movs	r3, #0
 8002114:	613b      	str	r3, [r7, #16]
 8002116:	2300      	movs	r3, #0
 8002118:	617b      	str	r3, [r7, #20]
 800211a:	2302      	movs	r3, #2
 800211c:	60fb      	str	r3, [r7, #12]
 800211e:	2300      	movs	r3, #0
 8002120:	60bb      	str	r3, [r7, #8]
 8002122:	2302      	movs	r3, #2
 8002124:	607b      	str	r3, [r7, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8002126:	4b33      	ldr	r3, [pc, #204]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 8002128:	689b      	ldr	r3, [r3, #8]
 800212a:	f003 030c 	and.w	r3, r3, #12
 800212e:	613b      	str	r3, [r7, #16]

  switch (tmp)
 8002130:	693b      	ldr	r3, [r7, #16]
 8002132:	2b04      	cmp	r3, #4
 8002134:	d007      	beq.n	8002146 <SystemCoreClockUpdate+0x3a>
 8002136:	2b08      	cmp	r3, #8
 8002138:	d009      	beq.n	800214e <SystemCoreClockUpdate+0x42>
 800213a:	2b00      	cmp	r3, #0
 800213c:	d13f      	bne.n	80021be <SystemCoreClockUpdate+0xb2>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 800213e:	4b2e      	ldr	r3, [pc, #184]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 8002140:	4a2e      	ldr	r2, [pc, #184]	; (80021fc <SystemCoreClockUpdate+0xf0>)
 8002142:	601a      	str	r2, [r3, #0]
      break;
 8002144:	e03f      	b.n	80021c6 <SystemCoreClockUpdate+0xba>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8002146:	4b2c      	ldr	r3, [pc, #176]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 8002148:	4a2d      	ldr	r2, [pc, #180]	; (8002200 <SystemCoreClockUpdate+0xf4>)
 800214a:	601a      	str	r2, [r3, #0]
      break;
 800214c:	e03b      	b.n	80021c6 <SystemCoreClockUpdate+0xba>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800214e:	4b29      	ldr	r3, [pc, #164]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 8002150:	685b      	ldr	r3, [r3, #4]
 8002152:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8002156:	0d9b      	lsrs	r3, r3, #22
 8002158:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800215a:	4b26      	ldr	r3, [pc, #152]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 800215c:	685b      	ldr	r3, [r3, #4]
 800215e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8002162:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
 8002164:	68bb      	ldr	r3, [r7, #8]
 8002166:	2b00      	cmp	r3, #0
 8002168:	d00d      	beq.n	8002186 <SystemCoreClockUpdate+0x7a>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800216a:	4a25      	ldr	r2, [pc, #148]	; (8002200 <SystemCoreClockUpdate+0xf4>)
 800216c:	687b      	ldr	r3, [r7, #4]
 800216e:	fbb2 f2f3 	udiv	r2, r2, r3
 8002172:	4b20      	ldr	r3, [pc, #128]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 8002174:	6859      	ldr	r1, [r3, #4]
 8002176:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800217a:	400b      	ands	r3, r1
 800217c:	099b      	lsrs	r3, r3, #6
 800217e:	fb03 f302 	mul.w	r3, r3, r2
 8002182:	617b      	str	r3, [r7, #20]
 8002184:	e00c      	b.n	80021a0 <SystemCoreClockUpdate+0x94>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8002186:	4a1d      	ldr	r2, [pc, #116]	; (80021fc <SystemCoreClockUpdate+0xf0>)
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	fbb2 f2f3 	udiv	r2, r2, r3
 800218e:	4b19      	ldr	r3, [pc, #100]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 8002190:	6859      	ldr	r1, [r3, #4]
 8002192:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8002196:	400b      	ands	r3, r1
 8002198:	099b      	lsrs	r3, r3, #6
 800219a:	fb03 f302 	mul.w	r3, r3, r2
 800219e:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80021a0:	4b14      	ldr	r3, [pc, #80]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 80021a2:	685b      	ldr	r3, [r3, #4]
 80021a4:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80021a8:	0c1b      	lsrs	r3, r3, #16
 80021aa:	3301      	adds	r3, #1
 80021ac:	005b      	lsls	r3, r3, #1
 80021ae:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
 80021b0:	697a      	ldr	r2, [r7, #20]
 80021b2:	68fb      	ldr	r3, [r7, #12]
 80021b4:	fbb2 f3f3 	udiv	r3, r2, r3
 80021b8:	4a0f      	ldr	r2, [pc, #60]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 80021ba:	6013      	str	r3, [r2, #0]
      break;
 80021bc:	e003      	b.n	80021c6 <SystemCoreClockUpdate+0xba>
    default:
      SystemCoreClock = HSI_VALUE;
 80021be:	4b0e      	ldr	r3, [pc, #56]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 80021c0:	4a0e      	ldr	r2, [pc, #56]	; (80021fc <SystemCoreClockUpdate+0xf0>)
 80021c2:	601a      	str	r2, [r3, #0]
      break;
 80021c4:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80021c6:	4b0b      	ldr	r3, [pc, #44]	; (80021f4 <SystemCoreClockUpdate+0xe8>)
 80021c8:	689b      	ldr	r3, [r3, #8]
 80021ca:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80021ce:	091b      	lsrs	r3, r3, #4
 80021d0:	4a0c      	ldr	r2, [pc, #48]	; (8002204 <SystemCoreClockUpdate+0xf8>)
 80021d2:	5cd3      	ldrb	r3, [r2, r3]
 80021d4:	b2db      	uxtb	r3, r3
 80021d6:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 80021d8:	4b07      	ldr	r3, [pc, #28]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 80021da:	681a      	ldr	r2, [r3, #0]
 80021dc:	693b      	ldr	r3, [r7, #16]
 80021de:	fa22 f303 	lsr.w	r3, r2, r3
 80021e2:	4a05      	ldr	r2, [pc, #20]	; (80021f8 <SystemCoreClockUpdate+0xec>)
 80021e4:	6013      	str	r3, [r2, #0]
}
 80021e6:	bf00      	nop
 80021e8:	371c      	adds	r7, #28
 80021ea:	46bd      	mov	sp, r7
 80021ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021f0:	4770      	bx	lr
 80021f2:	bf00      	nop
 80021f4:	40023800 	.word	0x40023800
 80021f8:	20000028 	.word	0x20000028
 80021fc:	00f42400 	.word	0x00f42400
 8002200:	007a1200 	.word	0x007a1200
 8002204:	2000002c 	.word	0x2000002c

08002208 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8002208:	b480      	push	{r7}
 800220a:	b083      	sub	sp, #12
 800220c:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800220e:	2300      	movs	r3, #0
 8002210:	607b      	str	r3, [r7, #4]
 8002212:	2300      	movs	r3, #0
 8002214:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8002216:	4a36      	ldr	r2, [pc, #216]	; (80022f0 <SetSysClock+0xe8>)
 8002218:	4b35      	ldr	r3, [pc, #212]	; (80022f0 <SetSysClock+0xe8>)
 800221a:	681b      	ldr	r3, [r3, #0]
 800221c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002220:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8002222:	4b33      	ldr	r3, [pc, #204]	; (80022f0 <SetSysClock+0xe8>)
 8002224:	681b      	ldr	r3, [r3, #0]
 8002226:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800222a:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 800222c:	687b      	ldr	r3, [r7, #4]
 800222e:	3301      	adds	r3, #1
 8002230:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8002232:	683b      	ldr	r3, [r7, #0]
 8002234:	2b00      	cmp	r3, #0
 8002236:	d103      	bne.n	8002240 <SetSysClock+0x38>
 8002238:	687b      	ldr	r3, [r7, #4]
 800223a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800223e:	d1f0      	bne.n	8002222 <SetSysClock+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8002240:	4b2b      	ldr	r3, [pc, #172]	; (80022f0 <SetSysClock+0xe8>)
 8002242:	681b      	ldr	r3, [r3, #0]
 8002244:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002248:	2b00      	cmp	r3, #0
 800224a:	d002      	beq.n	8002252 <SetSysClock+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 800224c:	2301      	movs	r3, #1
 800224e:	603b      	str	r3, [r7, #0]
 8002250:	e001      	b.n	8002256 <SetSysClock+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8002252:	2300      	movs	r3, #0
 8002254:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8002256:	683b      	ldr	r3, [r7, #0]
 8002258:	2b01      	cmp	r3, #1
 800225a:	d142      	bne.n	80022e2 <SetSysClock+0xda>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800225c:	4a24      	ldr	r2, [pc, #144]	; (80022f0 <SetSysClock+0xe8>)
 800225e:	4b24      	ldr	r3, [pc, #144]	; (80022f0 <SetSysClock+0xe8>)
 8002260:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002262:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002266:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 8002268:	4a22      	ldr	r2, [pc, #136]	; (80022f4 <SetSysClock+0xec>)
 800226a:	4b22      	ldr	r3, [pc, #136]	; (80022f4 <SetSysClock+0xec>)
 800226c:	681b      	ldr	r3, [r3, #0]
 800226e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002272:	6013      	str	r3, [r2, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8002274:	4a1e      	ldr	r2, [pc, #120]	; (80022f0 <SetSysClock+0xe8>)
 8002276:	4b1e      	ldr	r3, [pc, #120]	; (80022f0 <SetSysClock+0xe8>)
 8002278:	689b      	ldr	r3, [r3, #8]
 800227a:	6093      	str	r3, [r2, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 800227c:	4a1c      	ldr	r2, [pc, #112]	; (80022f0 <SetSysClock+0xe8>)
 800227e:	4b1c      	ldr	r3, [pc, #112]	; (80022f0 <SetSysClock+0xe8>)
 8002280:	689b      	ldr	r3, [r3, #8]
 8002282:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002286:	6093      	str	r3, [r2, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8002288:	4a19      	ldr	r2, [pc, #100]	; (80022f0 <SetSysClock+0xe8>)
 800228a:	4b19      	ldr	r3, [pc, #100]	; (80022f0 <SetSysClock+0xe8>)
 800228c:	689b      	ldr	r3, [r3, #8]
 800228e:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
 8002292:	6093      	str	r3, [r2, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8002294:	4b16      	ldr	r3, [pc, #88]	; (80022f0 <SetSysClock+0xe8>)
 8002296:	4a18      	ldr	r2, [pc, #96]	; (80022f8 <SetSysClock+0xf0>)
 8002298:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 800229a:	4a15      	ldr	r2, [pc, #84]	; (80022f0 <SetSysClock+0xe8>)
 800229c:	4b14      	ldr	r3, [pc, #80]	; (80022f0 <SetSysClock+0xe8>)
 800229e:	681b      	ldr	r3, [r3, #0]
 80022a0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80022a4:	6013      	str	r3, [r2, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80022a6:	bf00      	nop
 80022a8:	4b11      	ldr	r3, [pc, #68]	; (80022f0 <SetSysClock+0xe8>)
 80022aa:	681b      	ldr	r3, [r3, #0]
 80022ac:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80022b0:	2b00      	cmp	r3, #0
 80022b2:	d0f9      	beq.n	80022a8 <SetSysClock+0xa0>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80022b4:	4b11      	ldr	r3, [pc, #68]	; (80022fc <SetSysClock+0xf4>)
 80022b6:	f240 6205 	movw	r2, #1541	; 0x605
 80022ba:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80022bc:	4a0c      	ldr	r2, [pc, #48]	; (80022f0 <SetSysClock+0xe8>)
 80022be:	4b0c      	ldr	r3, [pc, #48]	; (80022f0 <SetSysClock+0xe8>)
 80022c0:	689b      	ldr	r3, [r3, #8]
 80022c2:	f023 0303 	bic.w	r3, r3, #3
 80022c6:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 80022c8:	4a09      	ldr	r2, [pc, #36]	; (80022f0 <SetSysClock+0xe8>)
 80022ca:	4b09      	ldr	r3, [pc, #36]	; (80022f0 <SetSysClock+0xe8>)
 80022cc:	689b      	ldr	r3, [r3, #8]
 80022ce:	f043 0302 	orr.w	r3, r3, #2
 80022d2:	6093      	str	r3, [r2, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80022d4:	bf00      	nop
 80022d6:	4b06      	ldr	r3, [pc, #24]	; (80022f0 <SetSysClock+0xe8>)
 80022d8:	689b      	ldr	r3, [r3, #8]
 80022da:	f003 030c 	and.w	r3, r3, #12
 80022de:	2b08      	cmp	r3, #8
 80022e0:	d1f9      	bne.n	80022d6 <SetSysClock+0xce>
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }

}
 80022e2:	bf00      	nop
 80022e4:	370c      	adds	r7, #12
 80022e6:	46bd      	mov	sp, r7
 80022e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022ec:	4770      	bx	lr
 80022ee:	bf00      	nop
 80022f0:	40023800 	.word	0x40023800
 80022f4:	40007000 	.word	0x40007000
 80022f8:	07405408 	.word	0x07405408
 80022fc:	40023c00 	.word	0x40023c00

08002300 <__libc_init_array>:
 8002300:	b570      	push	{r4, r5, r6, lr}
 8002302:	4b0e      	ldr	r3, [pc, #56]	; (800233c <__libc_init_array+0x3c>)
 8002304:	4c0e      	ldr	r4, [pc, #56]	; (8002340 <__libc_init_array+0x40>)
 8002306:	1ae4      	subs	r4, r4, r3
 8002308:	10a4      	asrs	r4, r4, #2
 800230a:	2500      	movs	r5, #0
 800230c:	461e      	mov	r6, r3
 800230e:	42a5      	cmp	r5, r4
 8002310:	d004      	beq.n	800231c <__libc_init_array+0x1c>
 8002312:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002316:	4798      	blx	r3
 8002318:	3501      	adds	r5, #1
 800231a:	e7f8      	b.n	800230e <__libc_init_array+0xe>
 800231c:	f000 f816 	bl	800234c <_init>
 8002320:	4c08      	ldr	r4, [pc, #32]	; (8002344 <__libc_init_array+0x44>)
 8002322:	4b09      	ldr	r3, [pc, #36]	; (8002348 <__libc_init_array+0x48>)
 8002324:	1ae4      	subs	r4, r4, r3
 8002326:	10a4      	asrs	r4, r4, #2
 8002328:	2500      	movs	r5, #0
 800232a:	461e      	mov	r6, r3
 800232c:	42a5      	cmp	r5, r4
 800232e:	d004      	beq.n	800233a <__libc_init_array+0x3a>
 8002330:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002334:	4798      	blx	r3
 8002336:	3501      	adds	r5, #1
 8002338:	e7f8      	b.n	800232c <__libc_init_array+0x2c>
 800233a:	bd70      	pop	{r4, r5, r6, pc}
 800233c:	0800237c 	.word	0x0800237c
 8002340:	0800237c 	.word	0x0800237c
 8002344:	08002380 	.word	0x08002380
 8002348:	0800237c 	.word	0x0800237c

0800234c <_init>:
 800234c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800234e:	bf00      	nop
 8002350:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002352:	bc08      	pop	{r3}
 8002354:	469e      	mov	lr, r3
 8002356:	4770      	bx	lr

08002358 <_fini>:
 8002358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800235a:	bf00      	nop
 800235c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800235e:	bc08      	pop	{r3}
 8002360:	469e      	mov	lr, r3
 8002362:	4770      	bx	lr
