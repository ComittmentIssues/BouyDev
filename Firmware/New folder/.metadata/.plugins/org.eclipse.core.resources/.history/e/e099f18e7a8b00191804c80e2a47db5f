/*
 * SD_Card.c
 * Adapted for SPL from https://github.com/afiskon/stm32-sdcard/blob/master/sdcard/sdcard.c#L92
 * Further reading http://www.dejazzer.com/ee379/lecture_notes/lec12_sd_card.pdf
 *  Created on: Jun 9, 2019
 *      Author: Jamie
 */
#include "SD_Card.h"
#include "tm_stm32f4_spi.h"
#include "stdio.h"
void SD_Card_Sel(FunctionalState en)
{
	if(!en)
	{
		GPIO_WriteBit(GPIOB,GPIO_PIN_5,RESET);
	}
	else
	{
		GPIO_WriteBit(GPIOB,GPIO_PIN_5,SET);
	}
}
void SD_command(uint8_t cmd, uint32_t arg, uint8_t crc)
{
    // transmit command to sd card
    TM_SPI_Send(SPI1,cmd|0x40);

    // transmit argument
    TM_SPI_Send(SPI1,(uint8_t)(arg >> 24));
    TM_SPI_Send(SPI1,(uint8_t)(arg >> 16));
    TM_SPI_Send(SPI1,(uint8_t)(arg >> 8));
    TM_SPI_Send(SPI1,(uint8_t)(arg));

    // transmit crc
    TM_SPI_Send(SPI1,(crc|0x01));
}
void init_GPIO_CHIPSELECT(void)
{
	TM_GPIO_Init(GPIOB,GPIO_PIN_5,TM_GPIO_Mode_OUT,TM_GPIO_OType_PP,TM_GPIO_PuPd_DOWN,TM_GPIO_Speed_Fast);
}

/*
 * Read 8bit return from SD card
 *
 * format:
 *  		7th bit	:	cmd arg outside range
 *  		6th bit :	misaligned address in command
 *  		5th bit :	error in sequence of commands
 *  		4th bit :	crc check error
 *  		3rd bit :	illigal command
 *  		2nd bit :	rase sequence clear
 *  		1st bit :	card in idle state
 */

uint8_t SD_CARD_ReadR1(void)
{
	 uint8_t r1;
	    // make sure FF is transmitted during receive
	    uint8_t tx = 0xFF;
	    for(;;) {
	    	TM_SPI_SendMulti(SPI1,&tx,&r1,1);
	        if((r1 & 0x80) == 0) // 8th bit alwyas zero, r1 recevied
	            break;
	    }
	    return r1;
}

static int SDCARD_ReadBytes(uint8_t* buff, size_t buff_size) {
    // make sure FF is transmitted during receive
    uint8_t tx = 0xFF;
    while(buff_size > 0) {
    	TM_SPI_ReadMulti(SPI1,buff,tx,buff_size);
        //HAL_SPI_TransmitReceive(&SDCARD_SPI_PORT, &tx, buff, 1, HAL_MAX_DELAY);
        buff++;
        buff_size--;
    }

    return 0;
}

static int SDCARD_WaitNotBusy(void)
{
    uint8_t busy;
    do {
        if(SDCARD_ReadBytes(&busy, sizeof(busy)) < 0) {
            return -1;
        }
    } while(busy != 0xFF);

    return 0;
}

uint8_t init_SDCARD(void)
{
	/*
	 * SET sd Card to SPI mode by setting MOSI and CS lines to logic value 1 and toggling the clock line for 74 pulse
	 */
	SD_Card_Sel(ENABLE);
	uint8_t data = 0b11111111;//high
	for (uint8_t i = 0; i < 10; ++i)
	{
		TM_SPI_Send(SPI1,data);
	}
	/*
	 * Set CSEL low and wait until SD card is free then send the reset command
	 */
	SD_Card_Sel(DISABLE);

	if(SDCARD_WaitNotBusy() < 0)
	{
	        SD_Card_Sel(ENABLE);
	        return -1;
	}

    uint8_t CMD0[] = {0b01000000,0b00000000,0b00000000,0b00000000,0b00000000,0b10010101};
	TM_SPI_WriteMulti(SPI1,CMD0,6);

	if(SD_CARD_ReadR1() != 0x01)
	{
	        SD_Card_Sel(ENABLE);
	        return -1;
	 }

	/*
	 * Step 3: Transmit CMD8. This step will only work if the card  accepted,
	 * the card will return R1 + 32bit response
	 */
	if(SDCARD_WaitNotBusy()<0)
	{
		SD_Card_Sel(ENABLE);
		return -1;
	}

	//CMD8: 0b01001000, ARG = 0x0001AA CRC = 0x87, STop Bit = 1
	uint8_t CMD8[] = {0x48,0x00,0x00,0x1,0xAA,0x43<<1 |1};
	TM_SPI_WriteMulti(SPI1,CMD8,6);
	uint8_t r1 = SD_CARD_ReadR1();
	uint8_t resp[4];
	if(r1 != 0x01)
	{
	        SD_Card_Sel(ENABLE);
	        return -2; // not an SDHC/SDXC card (i.e. SDSC, not supported)
	    }
	TM_SPI_ReadMulti(SPI1,resp,0xFF,4);
	//check CRC bit
	uint16_t crc = (resp[2]<<8) |resp[3];
	if(crc != 0x1aa)
	{
		 SD_Card_Sel(ENABLE);
		 return -3;
	}


	/*
	 * Step 4: read OCR to determine current voltage opperation
	 */
	//read OCR
	if(SDCARD_WaitNotBusy()<0)
		{
			SD_Card_Sel(ENABLE);
			return -1;
		}
	uint8_t CMD58[] = {0b01111010,0x00,0x00,0x00,0x00,0b1110101};
	TM_SPI_WriteMulti(SPI1,CMD58,6);
	r1 = SD_CARD_ReadR1();
	uint8_t resp1[4];
	TM_SPI_ReadMulti(SPI1,resp1,0xFF,4);

	/*
	 * Step 5: ACMD41: send opperating condition
	 * note: must send CMD55 first to let the device know that this is applocation specific
	 */
	SD_Card_Sel(DISABLE);
	if(SDCARD_WaitNotBusy()<0)
	{
		SD_Card_Sel(ENABLE);
		return -1;
	}
	uint8_t CMD55[]  = { 0b01110111,0x00,0x00,0x00,0x00,(0x7F << 1) | 1};
	uint8_t ACMD41[] = { 0b01101001,0x40,0x00,0x00,0x00,(0x7F << 1) | 1};
	for(;;)
	{
		TM_SPI_WriteMulti(SPI1,CMD55,6);
		r1 = SD_CARD_ReadR1();
		if(r1 != 0x01)
		{
			SD_Card_Sel(ENABLE);
			return -2; // not an SDHC/SDXC card (i.e. SDSC, not supported)
		}

		if(SDCARD_WaitNotBusy()<0)
		{
			SD_Card_Sel(ENABLE);
			return -1;
		}


		TM_SPI_WriteMulti(SPI1,ACMD41,6);
		r1 = SD_CARD_ReadR1();
		if(r1 != 0x01)
		{
			SD_Card_Sel(ENABLE);
			return -1;
		}

		if(SDCARD_WaitNotBusy()<0)
		{
			SD_Card_Sel(ENABLE);
			return -1;
		}
	}

	return 0;
 }
